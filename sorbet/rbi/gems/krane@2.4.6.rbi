# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `krane` gem.
# Please instead update this file by running `bin/tapioca gem krane`.

module DelayedExceptions
  def with_delayed_exceptions(enumerable, *catch, &block); end
end

module Krane; end

module Krane::Annotation
  class << self
    def for(suffix); end
  end
end

class Krane::ClusterResourceDiscovery
  def initialize(task_config:, namespace_tags: T.unsafe(nil)); end

  def context(*_arg0, &_arg1); end
  def crds; end
  def fetch_mutating_webhook_configurations; end
  def fetch_resources(namespaced: T.unsafe(nil)); end
  def logger(*_arg0, &_arg1); end
  def namespace(*_arg0, &_arg1); end
  def prunable_resources(namespaced:); end

  private

  def api_paths; end
  def base_api_path; end
  def fetch_api_path(path); end
  def fetch_crds; end
  def kubectl; end
  def resource_hash(path, namespaced, blob); end
end

module Krane::Concurrency
  class << self
    def split_across_threads(all_work, max_threads: T.unsafe(nil), &block); end
  end
end

Krane::Concurrency::MAX_THREADS = T.let(T.unsafe(nil), Integer)

class Krane::ConfigMap < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

Krane::ConfigMap::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::ContainerLogs
  def initialize(parent_id:, container_name:, namespace:, context:, logger:); end

  def container_name; end
  def empty?; end
  def lines; end
  def print_all; end
  def print_latest(prefix: T.unsafe(nil)); end
  def printing_started?; end
  def sync; end

  private

  def fetch_latest; end
  def kubectl; end
  def likely_duplicate?(timestamp); end
  def rfc3339_timestamp(time); end
  def sort_and_deduplicate(logs); end
  def split_timestamped_line(log_line); end
end

Krane::ContainerLogs::DEFAULT_LINE_LIMIT = T.let(T.unsafe(nil), Integer)

class Krane::ContainerOverrides
  def initialize(command: T.unsafe(nil), arguments: T.unsafe(nil), env_vars: T.unsafe(nil), image_tag: T.unsafe(nil)); end

  def apply!(container); end
  def arguments; end
  def command; end
  def env_vars; end
  def image_tag; end
end

class Krane::CronJob < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def timeout_message; end
end

Krane::CronJob::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::CustomResource < ::Krane::KubernetesResource
  def initialize(namespace:, context:, definition:, logger:, crd:, statsd_tags: T.unsafe(nil)); end

  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def status; end
  def timeout; end
  def timeout_message; end
  def type; end
  def validate_definition(*_arg0, **_arg1); end

  private

  def kind; end
  def rollout_conditions; end
end

Krane::CustomResource::TIMEOUT_MESSAGE_DIFFERENT_GENERATIONS = T.let(T.unsafe(nil), String)

class Krane::CustomResourceDefinition < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def group; end
  def group_version_kind; end
  def kind; end
  def predeployed?; end
  def prunable?; end
  def rollout_conditions; end
  def status; end
  def timeout_for_instance; end
  def timeout_message; end
  def validate_definition(*_arg0, **_arg1); end
  def validate_rollout_conditions; end

  private

  def names_accepted_condition; end
  def names_accepted_status; end
end

Krane::CustomResourceDefinition::GLOBAL = T.let(T.unsafe(nil), TrueClass)
Krane::CustomResourceDefinition::ROLLOUT_CONDITIONS_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::CustomResourceDefinition::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)
Krane::CustomResourceDefinition::TIMEOUT_FOR_INSTANCE_ANNOTATION = T.let(T.unsafe(nil), String)

class Krane::DaemonSet < ::Krane::PodSetBase
  def deploy_failed?; end
  def deploy_succeeded?; end
  def fetch_debug_logs; end
  def pods; end
  def print_debug_logs?; end
  def status; end
  def sync(cache); end

  private

  def find_nodes(cache); end
  def parent_of_pod?(pod_data); end
  def refresh_nodes(cache); end
  def relevant_pods_ready?; end
  def rollout_data; end
end

class Krane::DaemonSet::Node
  def initialize(definition:); end

  def name; end

  class << self
    def kind; end
  end
end

Krane::DaemonSet::SYNC_DEPENDENCIES = T.let(T.unsafe(nil), Array)
Krane::DaemonSet::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

module Krane::DeferredSummaryLogging
  def initialize(*args); end

  def blank_line(level = T.unsafe(nil)); end
  def heading(text, secondary_msg = T.unsafe(nil), secondary_msg_color = T.unsafe(nil)); end
  def phase_heading(phase_name); end
  def print_summary(status); end
  def reset; end
  def summary; end
end

class Krane::DeferredSummaryLogging::DeferredSummary
  def initialize; end

  def actions_sentence; end
  def add_action(sentence_fragment); end
  def add_paragraph(paragraph); end
  def paragraphs; end
end

class Krane::DeployTask
  include ::Krane::DeployTask::InstrumentationProxy
  include ::Krane::TemplateReporting
  extend ::Krane::StatsD::MeasureMethods

  def initialize(namespace:, context:, current_sha: T.unsafe(nil), logger: T.unsafe(nil), kubectl_instance: T.unsafe(nil), bindings: T.unsafe(nil), global_timeout: T.unsafe(nil), selector: T.unsafe(nil), selector_as_filter: T.unsafe(nil), filenames: T.unsafe(nil), protected_namespaces: T.unsafe(nil), render_erb: T.unsafe(nil), kubeconfig: T.unsafe(nil)); end

  def kubeclient_builder(*_arg0, &_arg1); end
  def predeploy_sequence; end
  def prune_whitelist; end
  def run(**args); end
  def run!(verify_result: T.unsafe(nil), prune: T.unsafe(nil)); end
  def server_version; end
  def task_config; end

  private

  def cluster_resource_discoverer; end
  def confirm_ejson_keys_not_prunable; end
  def deploy_has_priority_resources?(resources); end
  def ejson_keys_secret; end
  def ejson_provisioners; end
  def kubectl; end
  def namespace_definition; end
  def partition_dry_run_resources(resources); end
  def resource_deployer; end
  def secrets_from_ejson; end
  def statsd_tags; end
  def tags_from_namespace_labels; end
  def validate_dry_run(resources); end
  def validate_globals(resources); end
  def with_retries(limit); end
end

module Krane::DeployTask::InstrumentationProxy
  def check_initial_status(*args, **kwargs, &block); end
  def discover_resources(*args, **kwargs, &block); end
  def validate_configuration(*args, **kwargs, &block); end
  def validate_resources(*args, **kwargs, &block); end
end

Krane::DeployTask::PROTECTED_NAMESPACES = T.let(T.unsafe(nil), Array)

class Krane::DeployTaskConfigValidator < ::Krane::TaskConfigValidator
  def initialize(protected_namespaces, prune, *arguments); end

  private

  def validate_protected_namespaces; end
end

class Krane::Deployment < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def deploy_timed_out?; end
  def failure_message; end
  def fetch_debug_logs; end
  def fetch_events(kubectl); end
  def pretty_timeout_type; end
  def print_debug_logs?; end
  def status; end
  def sync(cache); end
  def timeout_message; end
  def validate_definition(*_arg0, **_arg1); end

  private

  def current_generation; end
  def deploy_failing_to_progress?; end
  def desired_replicas; end
  def find_latest_rs(cache); end
  def max_unavailable; end
  def min_available_replicas; end
  def observed_generation; end
  def percent?(value); end
  def progress_condition; end
  def progress_deadline; end
  def required_rollout; end
  def rollout_annotation_err_msg; end
  def rollout_data; end
end

Krane::Deployment::DEFAULT_REQUIRED_ROLLOUT = T.let(T.unsafe(nil), String)
Krane::Deployment::REQUIRED_ROLLOUT_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::Deployment::REQUIRED_ROLLOUT_TYPES = T.let(T.unsafe(nil), Array)
Krane::Deployment::SYNC_DEPENDENCIES = T.let(T.unsafe(nil), Array)
Krane::Deployment::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)
class Krane::DeploymentTimeoutError < ::Krane::FatalDeploymentError; end

class Krane::DurationParser
  def initialize(value); end

  def parse!; end
end

class Krane::DurationParser::ParsingError < ::ArgumentError; end

class Krane::EjsonPrunableError < ::Krane::FatalDeploymentError
  def initialize; end
end

class Krane::EjsonSecretError < ::Krane::FatalDeploymentError
  def initialize(msg); end
end

class Krane::EjsonSecretProvisioner
  def initialize(task_config:, ejson_keys_secret:, ejson_file:, statsd_tags:, selector: T.unsafe(nil)); end

  def context(*_arg0, &_arg1); end
  def logger(*_arg0, &_arg1); end
  def namespace(*_arg0, &_arg1); end
  def resources; end

  private

  def build_secrets; end
  def decrypt_ejson(key_dir); end
  def encrypted_ejson; end
  def fetch_private_key_from_secret; end
  def generate_secret_resource(secret_name, secret_type, data); end
  def load_ejson_from_file; end
  def private_key; end
  def public_key; end
  def validate_secret_spec(secret_name, spec); end
  def with_decrypted_ejson; end
end

Krane::EjsonSecretProvisioner::EJSON_KEYS_SECRET = T.let(T.unsafe(nil), String)
Krane::EjsonSecretProvisioner::EJSON_SECRETS_FILE = T.let(T.unsafe(nil), String)
Krane::EjsonSecretProvisioner::EJSON_SECRET_KEY = T.let(T.unsafe(nil), String)
class Krane::FatalDeploymentError < ::StandardError; end
class Krane::FatalKubeAPIError < ::Krane::FatalDeploymentError; end

class Krane::FormattedLogger < ::Logger
  include ::Krane::DeferredSummaryLogging

  class << self
    def build(namespace = T.unsafe(nil), context = T.unsafe(nil), stream = T.unsafe(nil), verbose_prefix: T.unsafe(nil)); end
    def indent_four(str); end

    private

    def level_from_env; end
  end
end

class Krane::GlobalDeployTask
  include ::Krane::GlobalDeployTask::InstrumentationProxy
  include ::Krane::TemplateReporting
  extend ::Krane::StatsD::MeasureMethods

  def initialize(context:, global_timeout: T.unsafe(nil), selector: T.unsafe(nil), selector_as_filter: T.unsafe(nil), filenames: T.unsafe(nil), logger: T.unsafe(nil), kubeconfig: T.unsafe(nil)); end

  def context(*_arg0, &_arg1); end
  def global_kinds(*_arg0, &_arg1); end
  def kubeclient_builder(*_arg0, &_arg1); end
  def logger(*_arg0, &_arg1); end
  def run(**args); end
  def run!(verify_result: T.unsafe(nil), prune: T.unsafe(nil)); end
  def task_config; end

  private

  def cluster_resource_discoverer; end
  def deploy!(resources, verify_result, prune); end
  def kubectl; end
  def prune_whitelist; end
  def statsd_tags; end
  def validate_globals(resources); end
end

module Krane::GlobalDeployTask::InstrumentationProxy
  def check_initial_status(*args, **kwargs, &block); end
  def discover_resources(*args, **kwargs, &block); end
  def validate_configuration(*args, **kwargs, &block); end
  def validate_resources(*args, **kwargs, &block); end
end

class Krane::GlobalDeployTaskConfigValidator < ::Krane::TaskConfigValidator
  def initialize(*arguments); end
end

class Krane::HorizontalPodAutoscaler < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def kubectl_resource_type; end
  def status; end
  def timeout_message; end

  private

  def able_to_scale_condition; end
  def conditions; end
  def scaling_active_condition; end
  def scaling_disabled?; end
end

Krane::HorizontalPodAutoscaler::RECOVERABLE_CONDITION_PREFIX = T.let(T.unsafe(nil), String)
Krane::HorizontalPodAutoscaler::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::Ingress < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
end

Krane::Ingress::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::InvalidTemplateError < ::Krane::FatalDeploymentError
  def initialize(err, filename: T.unsafe(nil), content: T.unsafe(nil)); end

  def content; end
  def filename; end
  def filename=(_arg0); end
end

class Krane::Job < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def status; end

  private

  def done?; end
  def failed_status_condition; end
  def running?; end
end

Krane::Job::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::KubeclientBuilder
  def initialize(kubeconfig: T.unsafe(nil)); end

  def build_apiextensions_v1beta1_kubeclient(context); end
  def build_apps_v1_kubeclient(context); end
  def build_autoscaling_v1_kubeclient(context); end
  def build_batch_v1_kubeclient(context); end
  def build_batch_v1beta1_kubeclient(context); end
  def build_networking_v1_kubeclient(context); end
  def build_policy_v1beta1_kubeclient(context); end
  def build_rbac_v1_kubeclient(context); end
  def build_scheduling_v1beta1_kubeclient(context); end
  def build_storage_v1_kubeclient(context); end
  def build_v1_kubeclient(context); end
  def build_v1beta1_kubeclient(context); end
  def kubeconfig_files; end
  def validate_config_files; end
  def validate_config_files!; end

  private

  def build_kubeclient(api_version:, context:, endpoint_path: T.unsafe(nil)); end
end

class Krane::KubeclientBuilder::ContextMissingError < ::Krane::FatalDeploymentError
  def initialize(context_name, kubeconfig); end
end

class Krane::Kubectl
  def initialize(task_config:, log_failure_by_default:, default_timeout: T.unsafe(nil), output_is_sensitive_default: T.unsafe(nil)); end

  def client_version; end
  def context(*_arg0, &_arg1); end
  def dry_run_flag; end
  def kubeconfig(*_arg0, &_arg1); end
  def logger(*_arg0, &_arg1); end
  def namespace(*_arg0, &_arg1); end
  def retry_delay(attempt); end
  def run(*args, log_failure: T.unsafe(nil), use_context: T.unsafe(nil), use_namespace: T.unsafe(nil), output: T.unsafe(nil), raise_if_not_found: T.unsafe(nil), attempts: T.unsafe(nil), output_is_sensitive: T.unsafe(nil), retry_whitelist: T.unsafe(nil)); end
  def server_dry_run_enabled?; end
  def server_version; end
  def version_info; end

  private

  def build_command_from_options(args, use_namespace, use_context, output); end
  def extract_version_info_from_kubectl_response(response); end
  def retriable_err?(err, retry_whitelist); end
end

Krane::Kubectl::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Krane::Kubectl::ERROR_MATCHERS = T.let(T.unsafe(nil), Hash)
Krane::Kubectl::MAX_RETRY_DELAY = T.let(T.unsafe(nil), Integer)
class Krane::Kubectl::ResourceNotFoundError < ::StandardError; end
Krane::Kubectl::SERVER_DRY_RUN_MIN_VERSION = T.let(T.unsafe(nil), String)
class Krane::KubectlError < ::StandardError; end

class Krane::KubernetesResource
  def initialize(namespace:, context:, definition:, logger:, statsd_tags: T.unsafe(nil)); end

  def <=>(other); end
  def after_sync; end
  def context; end
  def current_generation; end
  def debug_message(cause = T.unsafe(nil), info_hash = T.unsafe(nil)); end
  def deploy_failed?; end
  def deploy_method; end
  def deploy_method_override; end
  def deploy_started?; end
  def deploy_started_at=(_arg0); end
  def deploy_succeeded?; end
  def deploy_timed_out?; end
  def disappeared?; end
  def exists?; end
  def failure_message; end
  def fetch_events(kubectl); end
  def file_path; end
  def global=(_arg0); end
  def global?; end
  def group; end
  def id; end
  def kubectl_resource_type; end
  def name; end
  def namespace; end
  def observed_generation; end
  def pretty_status; end
  def pretty_timeout_type; end
  def report_status_to_statsd(watch_time); end
  def selected?(selector); end
  def sensitive_template_content?; end
  def server_dry_run_validated?; end
  def server_dry_runnable_resource?; end
  def status; end
  def sync(cache); end
  def sync_debug_info(kubectl); end
  def terminating?; end
  def timeout; end
  def timeout_message; end
  def timeout_override; end
  def to_kubeclient_resource; end
  def type; end
  def type=(_arg0); end
  def use_generated_name(instance_data); end
  def uses_generate_name?; end
  def validate_definition(kubectl:, selector: T.unsafe(nil), dry_run: T.unsafe(nil)); end
  def validation_error_msg; end
  def validation_failed?; end
  def version; end

  private

  def create_definition_tempfile; end
  def file; end
  def krane_annotation_value(suffix); end
  def labels; end
  def print_debug_logs?; end
  def statsd_tags; end
  def validate_deploy_method_override_annotation; end
  def validate_selector(selector); end
  def validate_spec_with_kubectl(kubectl); end
  def validate_timeout_annotation; end
  def validate_with_local_dry_run(kubectl); end
  def validate_with_server_side_dry_run(kubectl); end

  class << self
    def build(context:, definition:, logger:, statsd_tags:, namespace: T.unsafe(nil), crd: T.unsafe(nil), global_names: T.unsafe(nil)); end
    def class_for_kind(kind); end
    def kind; end
    def timeout; end

    private

    def validate_definition_essentials(definition); end
  end
end

Krane::KubernetesResource::ALLOWED_DEPLOY_METHOD_OVERRIDES = T.let(T.unsafe(nil), Array)
Krane::KubernetesResource::DEBUG_RESOURCE_NOT_FOUND_MESSAGE = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::DEPLOY_METHOD_OVERRIDE_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::DISABLED_EVENT_INFO_MESSAGE = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::DISABLED_LOG_INFO_MESSAGE = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::DISABLE_FETCHING_EVENT_INFO = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::DISABLE_FETCHING_LOG_INFO = T.let(T.unsafe(nil), String)

class Krane::KubernetesResource::Event
  def initialize(subject_kind:, last_timestamp:, reason:, message:, count:, subject_name:); end

  def seen_since?(time); end
  def to_s; end

  class << self
    def extract_all_from_go_template_blob(blob); end
    def go_template_for(kind, name); end

    private

    def extract_event_count(pieces); end
    def extract_event_timestamp(pieces); end
  end
end

Krane::KubernetesResource::Event::EVENT_SEPARATOR = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::Event::FIELDS = T.let(T.unsafe(nil), Array)
Krane::KubernetesResource::Event::FIELD_EMPTY_VALUE = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::Event::FIELD_SEPARATOR = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::LAST_APPLIED_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::LOG_LINE_COUNT = T.let(T.unsafe(nil), Integer)
Krane::KubernetesResource::SERVER_DRY_RUN_DISABLED_ERROR = T.let(T.unsafe(nil), Regexp)
Krane::KubernetesResource::STANDARD_TIMEOUT_MESSAGE = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::SYNC_DEPENDENCIES = T.let(T.unsafe(nil), Array)
Krane::KubernetesResource::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)
Krane::KubernetesResource::TIMEOUT_OVERRIDE_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::KubernetesResource::UNUSUAL_FAILURE_MESSAGE = T.let(T.unsafe(nil), String)

class Krane::LabelSelector
  def initialize(hash); end

  def to_h; end
  def to_s; end

  class << self
    def parse(string); end
  end
end

Krane::MIN_KUBE_VERSION = T.let(T.unsafe(nil), String)

class Krane::MutatingWebhookConfiguration < ::Krane::KubernetesResource
  def initialize(namespace:, context:, definition:, logger:, statsd_tags:); end

  def deploy_succeeded?; end
  def webhooks; end
end

Krane::MutatingWebhookConfiguration::GLOBAL = T.let(T.unsafe(nil), TrueClass)
Krane::MutatingWebhookConfiguration::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::MutatingWebhookConfiguration::Webhook
  def initialize(definition); end

  def has_side_effects?; end
  def match_policy; end
  def matches_resource?(resource, skip_rule_if_side_effect_none: T.unsafe(nil)); end
  def rules; end
  def side_effects; end
end

Krane::MutatingWebhookConfiguration::Webhook::EQUIVALENT = T.let(T.unsafe(nil), String)
Krane::MutatingWebhookConfiguration::Webhook::EXACT = T.let(T.unsafe(nil), String)

class Krane::MutatingWebhookConfiguration::Webhook::Rule
  def initialize(definition); end

  def groups; end
  def matches_resource?(resource, accept_equivalent:); end
  def resources; end
  def versions; end
end

class Krane::NetworkPolicy < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

Krane::NetworkPolicy::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::PersistentVolumeClaim < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def failure_message; end
  def status; end
  def sync(cache); end
  def timeout_message; end

  private

  def storage_class; end
  def storage_class_name; end
end

class Krane::PersistentVolumeClaim::StorageClass < ::Krane::KubernetesResource
  def initialize(definition); end

  def default?; end
  def name; end
  def volume_binding_mode; end
end

Krane::PersistentVolumeClaim::StorageClass::DEFAULT_CLASS_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::PersistentVolumeClaim::StorageClass::DEFAULT_CLASS_BETA_ANNOTATION = T.let(T.unsafe(nil), String)
Krane::PersistentVolumeClaim::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::Pod < ::Krane::KubernetesResource
  def initialize(namespace:, context:, definition:, logger:, statsd_tags: T.unsafe(nil), parent: T.unsafe(nil), deploy_started_at: T.unsafe(nil), stream_logs: T.unsafe(nil)); end

  def after_sync; end
  def deploy_failed?; end
  def deploy_succeeded?; end
  def evicted?; end
  def failure_message; end
  def fetch_debug_logs; end
  def node_name; end
  def print_debug_logs?; end
  def status; end
  def stream_logs; end
  def stream_logs=(_arg0); end
  def sync(_cache); end
  def timeout_message; end

  private

  def failed_phase?; end
  def failed_schedule_reason; end
  def logs; end
  def phase; end
  def phase_failure_message; end
  def raise_predates_deploy_error; end
  def readiness_probe_failure?; end
  def ready?; end
  def reason; end
  def transient_failure_reason?; end
  def unmanaged?; end
  def update_container_statuses(status_data); end
end

class Krane::Pod::Container
  def initialize(definition, init_container: T.unsafe(nil)); end

  def doom_reason; end
  def doomed?; end
  def init_container?; end
  def name; end
  def readiness_fail_reason; end
  def ready?; end
  def reset_status; end
  def update_status(data); end
end

Krane::Pod::FAILED_PHASE_NAME = T.let(T.unsafe(nil), String)
Krane::Pod::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)
Krane::Pod::TRANSIENT_FAILURE_REASONS = T.let(T.unsafe(nil), Array)

class Krane::PodDisruptionBudget < ::Krane::KubernetesResource
  def deploy_method; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

Krane::PodDisruptionBudget::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::PodSetBase < ::Krane::KubernetesResource
  def failure_message; end
  def fetch_debug_logs; end
  def fetch_events(kubectl); end
  def print_debug_logs?; end
  def timeout_message; end

  private

  def container_names; end
  def find_pods(cache); end
  def parent_of_pod?(_); end
  def pods; end
end

class Krane::PodTemplate < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

class Krane::RemoteLogs
  def initialize(logger:, parent_id:, container_names:, namespace:, context:); end

  def container_logs; end
  def empty?; end
  def print_all(prevent_duplicate: T.unsafe(nil)); end
  def print_latest; end
  def sync; end
end

class Krane::RenderTask
  def initialize(current_sha:, bindings:, logger: T.unsafe(nil), filenames: T.unsafe(nil)); end

  def run(**args); end
  def run!(stream:); end

  private

  def log_invalid_template(exception); end
  def render_templates(stream, template_sets); end
  def validate_configuration(template_sets); end
  def write_to_stream(rendered_content, filename, stream); end
end

class Krane::Renderer
  def initialize(current_sha:, template_dir:, logger:, bindings: T.unsafe(nil)); end

  def render_partial(partial, locals); end
  def render_template(filename, raw_template); end

  private

  def bind_template_variables(erb_binding, variables); end
  def find_partial(name); end
  def template_variables; end
end

class Krane::Renderer::InvalidPartialError < ::Krane::InvalidTemplateError
  def initialize(msg, filename:, parents: T.unsafe(nil), content: T.unsafe(nil)); end

  def content; end
  def content=(_arg0); end
  def filename; end
  def filename=(_arg0); end
  def parents; end
  def parents=(_arg0); end
end

class Krane::Renderer::PartialNotFound < ::Krane::InvalidTemplateError; end

class Krane::Renderer::TemplateContext
  def initialize(renderer); end

  def partial(partial, locals = T.unsafe(nil)); end
  def template_binding; end
end

class Krane::ReplicaSet < ::Krane::PodSetBase
  def initialize(namespace:, context:, definition:, logger:, statsd_tags: T.unsafe(nil), parent: T.unsafe(nil), deploy_started_at: T.unsafe(nil)); end

  def available_replicas; end
  def deploy_failed?; end
  def deploy_succeeded?; end
  def desired_replicas; end
  def pods; end
  def ready_replicas; end
  def status; end
  def sync(cache); end

  private

  def parent_of_pod?(pod_data); end
  def rollout_data; end
  def stale_status?; end
  def unmanaged?; end
end

Krane::ReplicaSet::SYNC_DEPENDENCIES = T.let(T.unsafe(nil), Array)
Krane::ReplicaSet::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::ResourceCache
  def initialize(task_config); end

  def context(*_arg0, &_arg1); end
  def get_all(kind, selector = T.unsafe(nil)); end
  def get_instance(kind, resource_name, raise_if_not_found: T.unsafe(nil)); end
  def logger(*_arg0, &_arg1); end
  def namespace(*_arg0, &_arg1); end
  def prewarm(resources); end

  private

  def fetch_by_kind(kind); end
  def statsd_tags; end
  def use_or_populate_cache(kind); end
end

class Krane::ResourceDeployer
  include ::Krane::ResourceDeployer::InstrumentationProxy
  include ::Krane::TemplateReporting
  extend ::Krane::StatsD::MeasureMethods

  def initialize(task_config:, prune_whitelist:, global_timeout:, selector:, statsd_tags:, current_sha: T.unsafe(nil)); end

  def deploy!(resources, verify_result, prune); end
  def dry_run(resources); end
  def logger(*_arg0, &_arg1); end
  def statsd_tags; end

  private

  def apply_all(resources, prune, dry_run: T.unsafe(nil)); end
  def create_resource(resource); end
  def deploy_resources(resources, verify:, prune: T.unsafe(nil), record_summary: T.unsafe(nil)); end
  def find_bad_files_from_kubectl_output(line); end
  def kubectl; end
  def log_pruning(kubectl_output); end
  def record_apply_failure(err, resources: T.unsafe(nil)); end
  def replace_or_create_resource(resource, force: T.unsafe(nil)); end
end

module Krane::ResourceDeployer::InstrumentationProxy
  def deploy_all_resources(*args, **kwargs, &block); end
  def predeploy_priority_resources(*args, **kwargs, &block); end
end

class Krane::ResourceQuota < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

Krane::ResourceQuota::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::ResourceWatcher
  include ::Krane::ResourceWatcher::InstrumentationProxy
  extend ::Krane::StatsD::MeasureMethods

  def initialize(resources:, task_config:, deploy_started_at: T.unsafe(nil), operation_name: T.unsafe(nil), timeout: T.unsafe(nil), sha: T.unsafe(nil)); end

  def context(*_arg0, &_arg1); end
  def logger(*_arg0, &_arg1); end
  def namespace(*_arg0, &_arg1); end
  def run(delay_sync: T.unsafe(nil), reminder_interval: T.unsafe(nil), record_summary: T.unsafe(nil)); end

  private

  def due_for_reminder?(last_message_logged_at, reminder_interval); end
  def global_timeout?(started_at); end
  def past_tense_operation; end
  def record_failed_statuses(failed_resources, global_timeouts = T.unsafe(nil)); end
  def record_statuses_for_summary(resources); end
  def record_success_statuses(successful_resources); end
  def report_and_give_up(remaining_resources); end
  def report_what_is_left(resources, reminder:); end
  def report_what_just_happened(new_successes, new_failures, new_timeouts); end
  def sleep_until_next_sync(min_interval); end
  def statsd_tags; end
end

module Krane::ResourceWatcher::InstrumentationProxy
  def sync_resources(*args, **kwargs, &block); end
end

class Krane::RestartTask
  def initialize(context:, namespace:, logger: T.unsafe(nil), global_timeout: T.unsafe(nil), kubeconfig: T.unsafe(nil)); end

  def kubeclient_builder(*_arg0, &_arg1); end
  def perform(**args); end
  def perform!(deployments: T.unsafe(nil), statefulsets: T.unsafe(nil), daemonsets: T.unsafe(nil), selector: T.unsafe(nil), verify_result: T.unsafe(nil)); end
  def run(**args); end
  def run!(deployments: T.unsafe(nil), statefulsets: T.unsafe(nil), daemonsets: T.unsafe(nil), selector: T.unsafe(nil), verify_result: T.unsafe(nil)); end
  def task_config; end

  private

  def apps_v1_kubeclient; end
  def build_patch_payload(_deployment); end
  def build_watchables(kubeclient_resources, started, klass); end
  def delete_statefulset_pods(record); end
  def fetch_daemonsets(list); end
  def fetch_deployments(list); end
  def fetch_statefulsets(list); end
  def identify_target_daemonsets(selector: T.unsafe(nil)); end
  def identify_target_deployments(selector: T.unsafe(nil)); end
  def identify_target_statefulsets(selector: T.unsafe(nil)); end
  def identify_target_workloads(deployment_names, statefulset_names, daemonset_names, selector: T.unsafe(nil)); end
  def identify_target_workloads_by_name(deployment_names, statefulset_names, daemonset_names); end
  def kubeclient; end
  def kubectl; end
  def patch_daemonset_with_restart(record); end
  def patch_deployment_with_restart(record); end
  def patch_statefulset_with_restart(record); end
  def restart_daemonsets!(daemonsets); end
  def restart_deployments!(deployments); end
  def restart_statefulsets!(statefulsets); end
  def tags(status, deployments, statefulsets, daemonsets); end
  def v1beta1_kubeclient; end
  def verify_config!; end
  def verify_restart(resources); end
end

Krane::RestartTask::ANNOTATION = T.let(T.unsafe(nil), String)
class Krane::RestartTask::FatalRestartError < ::Krane::FatalDeploymentError; end
Krane::RestartTask::HTTP_OK_RANGE = T.let(T.unsafe(nil), Range)
Krane::RestartTask::RESTART_TRIGGER_ANNOTATION = T.let(T.unsafe(nil), String)

class Krane::RestartTask::RestartAPIError < ::Krane::RestartTask::FatalRestartError
  def initialize(deployment_name, response); end
end

class Krane::RolloutConditions
  def initialize(conditions); end

  def failure_messages(instance_data); end
  def rollout_failed?(instance_data); end
  def rollout_successful?(instance_data); end
  def validate!; end

  private

  def validate_conditions(conditions, source_key, required: T.unsafe(nil)); end

  class << self
    def default_conditions; end
    def from_annotation(conditions_string); end
  end
end

Krane::RolloutConditions::VALID_FAILURE_CONDITION_KEYS = T.let(T.unsafe(nil), Array)
Krane::RolloutConditions::VALID_SUCCESS_CONDITION_KEYS = T.let(T.unsafe(nil), Array)
class Krane::RolloutConditionsError < ::StandardError; end

class Krane::RunnerTask
  def initialize(namespace:, context:, logger: T.unsafe(nil), global_timeout: T.unsafe(nil), kubeconfig: T.unsafe(nil)); end

  def kubeclient_builder(*_arg0, &_arg1); end
  def pod_name; end
  def run(**args); end
  def run!(template:, command:, arguments:, env_vars: T.unsafe(nil), image_tag: T.unsafe(nil), verify_result: T.unsafe(nil)); end
  def task_config; end

  private

  def build_pod(template_name, container_overrides, verify_result); end
  def build_pod_definition(base_template); end
  def create_pod(pod); end
  def ensure_valid_restart_policy!(template, verify); end
  def extract_task_runner_container(pod_definition); end
  def get_template(template_name); end
  def kubeclient; end
  def kubectl; end
  def record_status_once(pod); end
  def statsd_tags(status); end
  def validate_pod(pod); end
  def verify_config!(task_template); end
  def watch_pod(pod); end
end

class Krane::RunnerTask::TaskTemplateMissingError < ::Krane::TaskConfigurationError; end

class Krane::RunnerTaskConfigValidator < ::Krane::TaskConfigValidator
  def initialize(template, *arguments); end

  private

  def validate_template; end
end

class Krane::Secret < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

Krane::Secret::SENSITIVE_TEMPLATE_CONTENT = T.let(T.unsafe(nil), TrueClass)
Krane::Secret::SERVER_DRY_RUNNABLE = T.let(T.unsafe(nil), TrueClass)
Krane::Secret::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::Service < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def sync(cache); end
  def timeout_message; end

  private

  def exposes_zero_replica_workload?; end
  def external_name_svc?; end
  def fetch_related_workloads(cache); end
  def published?; end
  def related_replica_count; end
  def requires_endpoints?; end
  def requires_publishing?; end
  def selector; end
  def selects_some_pods?; end
end

Krane::Service::SYNC_DEPENDENCIES = T.let(T.unsafe(nil), Array)
Krane::Service::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::ServiceAccount < ::Krane::KubernetesResource
  def deploy_failed?; end
  def deploy_succeeded?; end
  def status; end
  def timeout_message; end
end

Krane::ServiceAccount::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::StatefulSet < ::Krane::PodSetBase
  def deploy_failed?; end
  def deploy_succeeded?; end
  def pods; end
  def status; end
  def sync(cache); end

  private

  def desired_replicas; end
  def parent_of_pod?(pod_data); end
  def status_data; end
  def update_strategy; end
end

Krane::StatefulSet::ONDELETE = T.let(T.unsafe(nil), String)
Krane::StatefulSet::SYNC_DEPENDENCIES = T.let(T.unsafe(nil), Array)
Krane::StatefulSet::TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

class Krane::StatsD
  class << self
    def client; end
    def duration(start_time); end
  end
end

module Krane::StatsD::MeasureMethods
  def measure_method(method_name, metric = T.unsafe(nil)); end
end

Krane::StatsD::PREFIX = T.let(T.unsafe(nil), String)

class Krane::TaskConfig
  def initialize(context, namespace, logger = T.unsafe(nil), kubeconfig = T.unsafe(nil)); end

  def context; end
  def global_kinds; end
  def kubeclient_builder; end
  def kubeconfig; end
  def logger; end
  def namespace; end
end

class Krane::TaskConfigValidator
  def initialize(task_config, kubectl, kubeclient_builder, only: T.unsafe(nil)); end

  def context(*_arg0, &_arg1); end
  def errors; end
  def logger(*_arg0, &_arg1); end
  def namespace(*_arg0, &_arg1); end
  def valid?; end

  private

  def server_version_warning(server_version); end
  def validate_context_exists_in_kubeconfig; end
  def validate_context_reachable; end
  def validate_kubeconfig; end
  def validate_namespace_exists; end
  def validate_server_version; end
end

Krane::TaskConfigValidator::DEFAULT_VALIDATIONS = T.let(T.unsafe(nil), Array)
class Krane::TaskConfigurationError < ::Krane::FatalDeploymentError; end

module Krane::TemplateReporting
  def add_para_from_list(logger:, action:, enum:); end
  def record_invalid_template(logger:, err:, filename:, content: T.unsafe(nil)); end
end

class Krane::TemplateSets
  include ::DelayedExceptions

  def initialize(template_sets: T.unsafe(nil)); end

  def ejson_secrets_files; end
  def validate; end
  def with_resource_definitions(current_sha: T.unsafe(nil), bindings: T.unsafe(nil), raw: T.unsafe(nil)); end
  def with_resource_definitions_and_filename(current_sha: T.unsafe(nil), bindings: T.unsafe(nil), raw: T.unsafe(nil)); end

  private

  def deploying_with_erb_files?; end
  def rendering_erb_disabled?; end

  class << self
    def from_dirs_and_files(paths:, logger:, render_erb: T.unsafe(nil)); end
  end
end

class Krane::TemplateSets::TemplateSet
  include ::DelayedExceptions

  def initialize(template_dir:, logger:, file_whitelist: T.unsafe(nil), render_erb: T.unsafe(nil)); end

  def deploying_with_erb_files?; end
  def ejson_secrets_file; end
  def render_erb; end
  def validate; end
  def with_resource_definitions_and_filename(current_sha: T.unsafe(nil), bindings: T.unsafe(nil), raw: T.unsafe(nil)); end

  private

  def templates(filename:, raw:); end
end

Krane::TemplateSets::VALID_TEMPLATES = T.let(T.unsafe(nil), Array)
Krane::VERSION = T.let(T.unsafe(nil), String)

module PsychK8sCompatibility
  class << self
    def massage_node(n); end
  end
end
