# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kuby-core` gem.
# Please instead update this file by running `bin/tapioca gem kuby-core`.

module Kuby
  class << self
    def define(name, &block); end
    def definition; end
    def dependables; end
    def distros; end
    def env; end
    def env=(env_name); end
    def environment(name = T.unsafe(nil)); end
    def load!(config_file = T.unsafe(nil)); end
    def load_rake_tasks!; end
    def logger; end
    def logger=(_arg0); end
    def packages; end
    def plugins; end
    def providers; end
    def register_dependable(name, version_or_callable); end
    def register_distro(distro_name, distro_klass); end
    def register_package(package_name, package_def = T.unsafe(nil)); end
    def register_plugin(*args, **kwargs); end
    def register_provider(provider_name, provider_klass); end
  end
end

class Kuby::BasicLogger < ::Logger
  extend T::Sig

  def initialize(logdev, shift_age = T.unsafe(nil), shift_size = T.unsafe(nil), level: T.unsafe(nil), progname: T.unsafe(nil), formatter: T.unsafe(nil), datetime_format: T.unsafe(nil), shift_period_suffix: T.unsafe(nil)); end

  def fatal(progname_or_msg = T.unsafe(nil), &block); end
  def info(progname_or_msg = T.unsafe(nil), &block); end

  sig { returns(T.nilable(Process::Status)) }
  def last_status; end

  def with_pipes(out = T.unsafe(nil), err = T.unsafe(nil), &block); end
end

class Kuby::CLIBase
  extend T::Sig

  sig { params(block: AfterCallback).void }
  def after_execute(&block); end

  sig { params(block: BeforeCallback).void }
  def before_execute(&block); end

  sig { returns(T.nilable(Process::Status)) }
  def last_status; end

  sig { returns(T.nilable(T.any(IO, StringIO))) }
  def stderr; end

  def stderr=(new_stderr); end

  sig { returns(T.nilable(T.any(IO, StringIO))) }
  def stdout; end

  def stdout=(new_stdout); end
  def with_pipes(out = T.unsafe(nil), err = T.unsafe(nil), &block); end

  private

  def backticks(cmd); end
  def backticks_default(cmd); end
  def backticks_open3(cmd); end
  def execc(cmd); end
  def last_status=(status); end
  def open3_w(cmd, &block); end
  def run_after_callbacks(cmd); end
  def run_before_callbacks(cmd); end

  sig { returns(Symbol) }
  def status_key; end

  sig { returns(Symbol) }
  def stderr_key; end

  sig { returns(Symbol) }
  def stdout_key; end

  def systemm(cmd); end
  def systemm_default(cmd); end
  def systemm_open3(cmd); end
end

Kuby::CLIBase::AfterCallback = T.type_alias { T.proc.params(cmd: T::Array[::String], last_status: T.nilable(::Process::Status)).void }
Kuby::CLIBase::BeforeCallback = T.type_alias { T.proc.params(cmd: T::Array[::String]).void }

module Kuby::CockroachConsoleMonkeypatch
  def start; end
end

class Kuby::Commands
  extend ::GLI::DSL
  extend ::GLI::AppSupport
  extend ::GLI::App
  extend T::Sig
  extend GLI::App

  class << self
    def load_kuby_config!(global_options); end

    sig { returns(Kuby::Tasks) }
    def tasks; end
  end
end

Kuby::DEFAULT_DB_PASSWORD = T.let(T.unsafe(nil), String)
Kuby::DEFAULT_DB_USER = T.let(T.unsafe(nil), String)
Kuby::DEFAULT_ENV = T.let(T.unsafe(nil), String)

class Kuby::Definition
  extend T::Sig

  def initialize(app_name, &block); end

  def app_name; end
  def environment(name = T.unsafe(nil), &block); end

  sig { returns(T::Hash[Symbol, Kuby::Environment]) }
  def environments; end
end

class Kuby::Dependable
  def initialize(name, version_or_callable); end

  def name; end

  sig { returns(T.untyped) }
  def version; end

  def version_or_callable; end
end

class Kuby::Dependency
  def initialize(name, *constraints); end

  def constraints; end
  def name; end
  def satisfied_by?(dependable); end
end

module Kuby::Docker
  class PackageList
    include Enumerable
    extend T::Sig
    extend T::Generic

    sig { returns(T::Array[Distro::PackageImpl]) }
    attr_reader :packages

    sig { params(package_tuples: T::Array[[Symbol, T.nilable(String)]]).void }
    def initialize(package_tuples); end

    sig { params(name: Symbol).returns(T.nilable(Distro::PackageImpl)) }
    def [](name); end

    sig { params(name: Symbol, version: T.nilable(String)).void }
    def add(name, version = nil); end

    sig { params(name: String).void }
    def delete(name); end

    sig { override.params(block: T.proc.params(package: Distro::PackageImpl).void).void }
    def each(&block); end

    sig { returns(T::Boolean) }
    def empty?; end

    Elem = type_member {
  { fixed: Distro::PackageImpl }
}
  end
end

class Kuby::Docker::Alpine < ::Kuby::Docker::Distro
  sig { override.returns(T::Array[[Symbol, T.nilable(String)]]) }
  def default_packages; end

  def install(packages, into:); end
  def phase; end

  sig { override.returns(String) }
  def shell_exe; end

  private

  def install_managed(packages, dockerfile); end
  def install_unmanaged(packages, dockerfile); end
end

Kuby::Docker::Alpine::DEFAULT_PACKAGES = T.let(T.unsafe(nil), Array)
Kuby::Docker::Alpine::SHELL_EXE = T.let(T.unsafe(nil), String)

class Kuby::Docker::AppImage < ::Kuby::Docker::TimestampedImage
  extend T::Sig

  def initialize(dockerfile, image_url, credentials, registry_index_url = T.unsafe(nil), main_tag = T.unsafe(nil), alias_tags = T.unsafe(nil)); end
end

class Kuby::Docker::AppPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(environment); end

  def apply_to(dockerfile); end
  def env(key, value); end
end

class Kuby::Docker::AssetsPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def apply_to(dockerfile); end
end

class Kuby::Docker::BuildError < ::StandardError; end

class Kuby::Docker::BundlerPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(environment); end

  def apply_to(dockerfile); end
  def executable; end
  def executable=(_arg0); end
  def gemfile; end
  def gemfile=(_arg0); end

  sig { params(paths: String).void }
  def gemfiles(*paths); end

  def version; end
  def version=(_arg0); end
  def without; end
  def without=(_arg0); end

  private

  sig { returns(String) }
  def default_version; end
end

Kuby::Docker::BundlerPhase::DEFAULT_GEMFILE = T.let(T.unsafe(nil), String)
Kuby::Docker::BundlerPhase::DEFAULT_WITHOUT = T.let(T.unsafe(nil), Array)

class Kuby::Docker::CLI < ::Kuby::CLIBase
  extend T::Sig

  def initialize(executable = T.unsafe(nil)); end

  sig { returns(T::Array[String]) }
  def auths; end

  def build(image, build_args: T.unsafe(nil), docker_args: T.unsafe(nil), context: T.unsafe(nil), cache_from: T.unsafe(nil)); end

  sig { returns(T.nilable(String)) }
  def config_file; end

  sig { returns(String) }
  def default_config_file; end

  def exec_capture(container:, command:, tty: T.unsafe(nil)); end
  def executable; end
  def images(image_url, digests: T.unsafe(nil)); end
  def inspect(image_url:, tag: T.unsafe(nil), format: T.unsafe(nil)); end

  sig { params(url: String, username: String, password: String).void }
  def login(url:, username:, password:); end

  def pull(image_url, tag); end
  def push(image_url, tag); end
  def run(image_url:, tag: T.unsafe(nil), env: T.unsafe(nil), ports: T.unsafe(nil)); end

  sig { returns(Symbol) }
  def status_key; end

  sig { returns(Symbol) }
  def stderr_key; end

  sig { returns(Symbol) }
  def stdout_key; end
end

class Kuby::Docker::CopyPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(environment); end

  def <<(path); end
  def apply_to(dockerfile); end
  def paths; end
end

Kuby::Docker::CopyPhase::DEFAULT_PATHS = T.let(T.unsafe(nil), Array)

class Kuby::Docker::Credentials
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def email(*args); end
  def password(*args); end
  def username(*args); end
end

class Kuby::Docker::Debian < ::Kuby::Docker::Distro
  sig { override.returns(T::Array[[Symbol, T.nilable(String)]]) }
  def default_packages; end

  def install(packages, into:); end
  def phase; end

  sig { override.returns(String) }
  def shell_exe; end

  private

  def install_managed(packages, dockerfile); end
  def install_unmanaged(packages, dockerfile); end
end

Kuby::Docker::Debian::DEFAULT_PACKAGES = T.let(T.unsafe(nil), Array)
Kuby::Docker::Debian::SHELL_EXE = T.let(T.unsafe(nil), String)

class Kuby::Docker::Distro
  extend T::Sig
  extend T::Helpers

  abstract!

  def initialize(phase); end

  sig { returns(T::Array[[Symbol, T.nilable(String)]]) }
  def default_packages; end

  def install(packages, into:); end

  sig { returns(String) }
  def shell_exe; end
end

Kuby::Docker::Distro::ManagedPackageImpl = T.type_alias { T.any(::Kuby::Docker::Packages::ManagedPackage, ::Kuby::Docker::Packages::SimpleManagedPackage) }
Kuby::Docker::Distro::PackageImpl = T.type_alias { T.any(::Kuby::Docker::Packages::ManagedPackage, ::Kuby::Docker::Packages::Package, ::Kuby::Docker::Packages::SimpleManagedPackage) }

class Kuby::Docker::DockerURI
  extend T::Sig

  def initialize(host, port, path); end

  sig { returns(T::Boolean) }
  def has_default_port?; end

  def host; end
  def path; end
  def port; end

  class << self
    def parse(url, default_host:, default_port:); end
    def parse_index_uri(url); end
    def parse_uri(url); end
  end
end

Kuby::Docker::DockerURI::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Kuby::Docker::DockerURI::DEFAULT_REGISTRY_HOST = T.let(T.unsafe(nil), String)
Kuby::Docker::DockerURI::DEFAULT_REGISTRY_INDEX_HOST = T.let(T.unsafe(nil), String)

class Kuby::Docker::Dockerfile
  extend T::Sig

  sig { void }
  def initialize; end

  sig { params(args: String).void }
  def arg(*args); end

  sig { returns(String) }
  def checksum; end

  sig { params(args: String).void }
  def cmd(*args); end

  def commands; end
  def copy(source, dest, from: T.unsafe(nil)); end

  sig { returns(T.nilable(String)) }
  def current_workdir; end

  def cursor; end

  sig { params(args: String).void }
  def env(*args); end

  def expose(port); end

  sig { returns(T::Array[Integer]) }
  def exposed_ports; end

  def from(image_url, as: T.unsafe(nil)); end
  def insert_at(pos, &block); end

  sig { params(args: String).void }
  def run(*args); end

  sig { returns(String) }
  def to_s; end

  sig { params(args: String).void }
  def workdir(*args); end

  private

  def add(cmd); end
end

class Kuby::Docker::Dockerfile::Arg < ::Kuby::Docker::Dockerfile::Command
  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Cmd < ::Kuby::Docker::Dockerfile::Command
  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Command
  extend T::Sig

  def initialize(args); end

  def args; end

  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Copy < ::Kuby::Docker::Dockerfile::Command
  def initialize(source, dest, from: T.unsafe(nil)); end

  def dest; end
  def from; end
  def source; end

  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Env < ::Kuby::Docker::Dockerfile::Command
  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Expose < ::Kuby::Docker::Dockerfile::Command
  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::From < ::Kuby::Docker::Dockerfile::Command
  def initialize(image_url, as: T.unsafe(nil)); end

  def as; end
  def image_url; end

  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Run < ::Kuby::Docker::Dockerfile::Command
  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Dockerfile::Workdir < ::Kuby::Docker::Dockerfile::Command
  sig { returns(String) }
  def to_s; end
end

class Kuby::Docker::Image
  extend T::Sig

  def initialize(dockerfile, image_url, credentials, registry_index_url = T.unsafe(nil), main_tag = T.unsafe(nil), alias_tags = T.unsafe(nil)); end

  def alias_tags; end
  def build(build_args = T.unsafe(nil), docker_args = T.unsafe(nil), context: T.unsafe(nil), cache_from: T.unsafe(nil)); end
  def credentials; end

  sig { returns(Kuby::Docker::Image) }
  def current_version; end

  sig { returns(Kuby::Docker::CLI) }
  def docker_cli; end

  sig { returns(Kuby::Docker::Dockerfile) }
  def dockerfile; end

  def identifier; end

  sig { returns(String) }
  def image_host; end

  sig { returns(String) }
  def image_hostname; end

  sig { returns(String) }
  def image_repo; end

  sig { returns(Kuby::Docker::DockerURI) }
  def image_uri; end

  def image_url; end
  def main_tag; end

  sig { returns(Kuby::Docker::Image) }
  def new_version; end

  def previous_version(current_tag = T.unsafe(nil)); end
  def pull(tag); end
  def push(tag); end

  sig { returns(String) }
  def registry_index_host; end

  sig { returns(String) }
  def registry_index_hostname; end

  sig { returns(Kuby::Docker::DockerURI) }
  def registry_index_uri; end

  def registry_index_url; end

  sig { returns(T::Array[String]) }
  def tags; end

  private

  def duplicate_with_tags(main_tag, alias_tags); end
end

class Kuby::Docker::InlineLayer < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(block); end

  def apply_to(dockerfile); end
  def block; end
end

Kuby::Docker::LATEST_TAG = T.let(T.unsafe(nil), String)

class Kuby::Docker::Layer
  extend T::Sig
  extend T::Helpers

  abstract!

  def initialize(environment); end

  def apply_to(dockerfile); end
  def environment; end
end

class Kuby::Docker::LayerStack
  extend T::Generic
  include ::Enumerable
  include Enumerable
  extend T::Sig

  sig { void }
  def initialize; end

  def delete(name); end

  sig { override.params(block: T.nilable(T.proc.params(layer: Kuby::Docker::Layer).void)).void }
  def each(&block); end

  def includes?(name); end
  def insert(name, layer = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def layers; end
  def stack; end
  def use(name, layer = T.unsafe(nil), &block); end

  Elem = type_member {
  { fixed: Kuby::Docker::Layer }
}
end

class Kuby::Docker::LocalTags
  extend T::Sig

  def initialize(cli, image_url); end

  def cli; end
  def image_url; end

  sig { returns(T::Array[String]) }
  def latest_tags; end

  sig { returns(T.nilable(Kuby::Docker::TimestampTag)) }
  def latest_timestamp_tag; end

  sig { returns(T::Array[String]) }
  def tags; end

  sig { returns(T::Array[Kuby::Docker::TimestampTag]) }
  def timestamp_tags; end
end

class Kuby::Docker::LoginError < ::StandardError; end
class Kuby::Docker::MissingDistroError < ::StandardError; end
class Kuby::Docker::MissingPackageError < ::StandardError; end
class Kuby::Docker::MissingTagError < ::StandardError; end

class Kuby::Docker::PackagePhase < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(environment); end

  def add(package_name, version = T.unsafe(nil)); end
  def apply_to(dockerfile); end
  def operations; end
  def remove(package_name); end

  private

  sig { returns(Kuby::Docker::Distro) }
  def distro_spec; end

  def get_package(package_name, version); end
end

Kuby::Docker::PackagePhase::Operation = T.type_alias { [::Symbol, ::Symbol, T.nilable(::String)] }
module Kuby::Docker::Packages; end

class Kuby::Docker::Packages::ManagedPackage
  extend T::Sig

  def initialize(name, names_per_distro); end

  sig { returns(T::Boolean) }
  def managed?; end

  def name; end
  def names_per_distro; end
  def package_name_for(distro); end
  def with_version(ver); end
end

class Kuby::Docker::Packages::Nodejs < ::Kuby::Docker::Packages::Package
  extend T::Sig

  def install_on_alpine(dockerfile); end
  def install_on_debian(dockerfile); end

  sig { returns(String) }
  def version; end

  private

  def install_from_image(image, dockerfile); end
end

class Kuby::Docker::Packages::Package
  extend T::Sig
  extend T::Helpers

  abstract!

  def initialize(name, version = T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def managed?; end

  def name; end
  def version; end
  def with_version(ver); end
end

class Kuby::Docker::Packages::SimpleManagedPackage
  extend T::Sig

  def initialize(name); end

  sig { returns(T::Boolean) }
  def managed?; end

  def name; end
  def package_name_for(distro); end
  def with_version(ver); end
end

class Kuby::Docker::Packages::Yarn < ::Kuby::Docker::Packages::Package
  extend T::Sig

  def initialize(name, version = T.unsafe(nil)); end

  def install_on_alpine(dockerfile); end
  def install_on_debian(dockerfile); end

  private

  sig { returns(String) }
  def url; end
end

class Kuby::Docker::PullError < ::StandardError; end
class Kuby::Docker::PushError < ::StandardError; end

class Kuby::Docker::RemoteTags
  extend T::Sig

  def initialize(remote_client, image_url); end

  def image_url; end

  sig { returns(T::Array[String]) }
  def latest_tags; end

  def remote_client; end

  sig { returns(T::Array[String]) }
  def tags; end

  sig { returns(T::Array[Kuby::Docker::TimestampTag]) }
  def timestamp_tags; end
end

class Kuby::Docker::SetupPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(environment, docker_spec); end

  def apply_to(dockerfile); end

  sig { returns(String) }
  def base_image; end

  def base_image=(_arg0); end
  def docker_spec; end
  def rails_env; end
  def rails_env=(_arg0); end
  def working_dir; end
  def working_dir=(_arg0); end

  private

  sig { returns(String) }
  def default_base_image; end
end

Kuby::Docker::SetupPhase::DEFAULT_WORKING_DIR = T.let(T.unsafe(nil), String)

class Kuby::Docker::Spec
  extend T::Sig

  def initialize(environment); end

  sig { void }
  def after_configuration; end

  sig { returns(Kuby::Docker::AppPhase) }
  def app_phase; end

  def app_root(path); end
  def app_root_path; end

  sig { returns(Kuby::Docker::AssetsPhase) }
  def assets_phase; end

  def base_image(image_url); end

  sig { returns(Kuby::Docker::BundlerPhase) }
  def bundler_phase; end

  def bundler_version(version); end

  sig { returns(Kuby::Docker::CopyPhase) }
  def copy_phase; end

  sig { params(block: T.nilable(T.proc.void)).returns(Kuby::Docker::Credentials) }
  def credentials(&block); end

  def delete(name); end
  def distro(distro_name); end

  sig { returns(Symbol) }
  def distro_name; end

  sig { returns(Kuby::Docker::Distro) }
  def distro_spec; end

  def environment; end
  def exists?(name); end
  def files(path); end
  def gemfile(path); end
  def image; end
  def image_url(url); end
  def image_url_str; end
  def insert(name, layer = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def package(package_name, version = T.unsafe(nil)); end

  sig { returns(Kuby::Docker::PackagePhase) }
  def package_phase; end

  def port(port); end
  def rails_env(env); end
  def registry_index_url(url); end
  def registry_index_url_str; end

  sig { returns(Kuby::Docker::SetupPhase) }
  def setup_phase; end

  def use(name, layer = T.unsafe(nil), &block); end

  sig { returns(Kuby::Docker::WebserverPhase) }
  def webserver_phase; end

  def working_dir(dir); end

  sig { returns(Kuby::Docker::YarnPhase) }
  def yarn_phase; end

  private

  sig { returns(Kuby::Docker::LayerStack) }
  def layer_stack; end
end

Kuby::Docker::Spec::DEFAULT_APP_ROOT_PATH = T.let(T.unsafe(nil), String)
Kuby::Docker::Spec::DEFAULT_DISTRO = T.let(T.unsafe(nil), Symbol)

class Kuby::Docker::TimestampTag
  extend T::Sig

  def initialize(time); end

  def <=>(other); end
  def ==(other); end
  def eql?(other); end

  sig { returns(Integer) }
  def hash; end

  def time; end

  sig { returns(String) }
  def to_s; end

  class << self
    sig { returns(Kuby::Docker::TimestampTag) }
    def now; end

    def try_parse(str); end
  end
end

Kuby::Docker::TimestampTag::FORMAT = T.let(T.unsafe(nil), String)

class Kuby::Docker::TimestampedImage < ::Kuby::Docker::Image
  extend T::Sig

  def initialize(dockerfile, image_url, credentials, registry_index_url_str = T.unsafe(nil), main_tag = T.unsafe(nil), alias_tags = T.unsafe(nil)); end

  def build(build_args = T.unsafe(nil), docker_args = T.unsafe(nil), context: T.unsafe(nil), cache_from: T.unsafe(nil)); end

  sig { returns(Kuby::Docker::Image) }
  def current_version; end

  sig { returns(T::Boolean) }
  def exists?; end

  sig { returns(Kuby::Docker::TimestampTag) }
  def latest_timestamp_tag; end

  sig { returns(Kuby::Docker::Image) }
  def new_version; end

  def previous_timestamp_tag(current_tag = T.unsafe(nil)); end
  def previous_version(current_tag = T.unsafe(nil)); end
  def pull(tag); end
  def push(tag); end

  private

  sig { returns(Kuby::Docker::LocalTags) }
  def local; end

  sig { returns(Kuby::Docker::RemoteTags) }
  def remote; end

  sig { returns(::Docker::Remote::Client) }
  def remote_client; end

  sig { returns(T::Array[Kuby::Docker::TimestampTag]) }
  def timestamp_tags; end
end

class Kuby::Docker::UnsupportedDistroError < ::StandardError; end

class Kuby::Docker::WebserverPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def initialize(environment); end

  def apply_to(dockerfile); end

  sig { returns(Integer) }
  def port; end

  def port=(_arg0); end
  def webserver; end
  def webserver=(_arg0); end

  private

  sig { returns(T.nilable(Symbol)) }
  def default_webserver; end
end

Kuby::Docker::WebserverPhase::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

class Kuby::Docker::WebserverPhase::Puma < ::Kuby::Docker::WebserverPhase::Webserver
  def apply_to(dockerfile); end
end

Kuby::Docker::WebserverPhase::WEBSERVER_MAP = T.let(T.unsafe(nil), Hash)

class Kuby::Docker::WebserverPhase::Webserver
  extend T::Sig
  extend T::Helpers

  abstract!

  def initialize(phase); end

  def apply_to(dockerfile); end
  def phase; end
end

class Kuby::Docker::YarnPhase < ::Kuby::Docker::Layer
  extend T::Sig

  def apply_to(dockerfile); end

  private

  def ensure_trailing_delimiter(path); end
end

class Kuby::Environment
  def initialize(name, definition, &block); end

  sig { returns(T.untyped) }
  def app_name; end

  def configured; end
  def configured=(_arg0); end
  def configured?; end
  def definition; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def docker(&block); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def kubernetes(&block); end

  def name; end
end

module Kuby::Kubernetes; end

class Kuby::Kubernetes::BareMetalProvider < ::Kuby::Kubernetes::Provider
  extend T::Sig

  def initialize(environment); end

  def config; end

  sig { params(block: T.proc.void).void }
  def configure(&block); end

  sig { returns(String) }
  def kubeconfig_path; end

  sig { returns(String) }
  def storage_class_name; end

  private

  sig { void }
  def after_initialize; end
end

class Kuby::Kubernetes::BareMetalProvider::Config
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def kubeconfig(*args); end
  def storage_class(*args); end
end

Kuby::Kubernetes::BareMetalProvider::DEFAULT_STORAGE_CLASS = T.let(T.unsafe(nil), String)

class Kuby::Kubernetes::DeployTask
  sig { params(kwargs: T.untyped).void }
  def initialize(**kwargs); end

  def deploy_task; end

  sig { returns(T.untyped) }
  def logger; end

  sig { params(kwargs: T.untyped).returns(T.untyped) }
  def run!(**kwargs); end

  private

  def with_env(new_env); end
end

class Kuby::Kubernetes::Deployer
  def initialize(environment); end

  sig { returns(T.untyped) }
  def deploy; end

  def environment; end

  sig { returns(T.untyped) }
  def last_status; end

  sig { returns(T.untyped) }
  def logdev; end

  def logdev=(_arg0); end
  def with_pipes(out = T.unsafe(nil), err = T.unsafe(nil)); end

  private

  sig { returns(T.untyped) }
  def all_resources; end

  sig { returns(T.untyped) }
  def cli; end

  def deploy_global_resources(resources); end
  def deploy_namespaced_resources(resources, ns); end

  sig { returns(T.untyped) }
  def docker; end

  sig { returns(T.untyped) }
  def kubernetes; end

  sig { returns(T.untyped) }
  def namespace; end

  sig { returns(T.untyped) }
  def provider; end

  sig { returns(T.untyped) }
  def restart_rails_deployment_if_necessary; end
end

class Kuby::Kubernetes::DockerConfig
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  sig { params(block: T.untyped).void }
  def initialize(&block); end

  def email(*args); end
  def password(*args); end
  def registry_host(*args); end

  sig { returns(T.untyped) }
  def serialize; end

  def username(*args); end
end

class Kuby::Kubernetes::DockerDesktopProvider < ::Kuby::Kubernetes::Provider
  def config; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def configure(&block); end

  sig { returns(T.untyped) }
  def kubeconfig_path; end

  sig { returns(T.untyped) }
  def storage_class_name; end

  private

  sig { returns(T.untyped) }
  def after_initialize; end
end

class Kuby::Kubernetes::DockerDesktopProvider::Config
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def kubeconfig(*args); end
end

Kuby::Kubernetes::DockerDesktopProvider::STORAGE_CLASS_NAME = T.let(T.unsafe(nil), String)
class Kuby::Kubernetes::DuplicateResourceError < ::StandardError; end

class Kuby::Kubernetes::Manifest
  include ::Enumerable
  include Enumerable

  def initialize(resources); end

  def <<(resource); end
  def delete(kind, name); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def each(&block); end

  def find(kind, name); end

  private

  sig { returns(T.untyped) }
  def ensure_all_resources_unique!; end

  def matches?(resource, kind, name); end
end

class Kuby::Kubernetes::MissingDeploymentError < ::StandardError; end
class Kuby::Kubernetes::MissingPluginError < ::StandardError; end
class Kuby::Kubernetes::MissingProviderError < ::StandardError; end
class Kuby::Kubernetes::MissingResourceError < ::StandardError; end

class Kuby::Kubernetes::Provider
  def initialize(environment); end

  sig { returns(T.untyped) }
  def after_configuration; end

  def after_deploy(manifest); end

  sig { returns(T.untyped) }
  def after_setup; end

  def before_deploy(manifest); end

  sig { returns(T.untyped) }
  def before_setup; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def configure(&block); end

  sig { returns(T.untyped) }
  def deploy; end

  sig { returns(T.untyped) }
  def deployer; end

  def environment; end

  sig { returns(T.untyped) }
  def helm_cli; end

  sig { returns(T.untyped) }
  def kubeconfig_path; end

  sig { returns(T.untyped) }
  def kubernetes_cli; end

  sig { returns(T.untyped) }
  def rollback; end

  sig { returns(T.untyped) }
  def setup; end

  private

  sig { returns(T.untyped) }
  def after_initialize; end

  sig { returns(T.untyped) }
  def spec; end
end

class Kuby::Kubernetes::RegistrySecret < ::KubeDSL::DSL::V1::Secret
  sig { params(block: T.untyped).void }
  def initialize(&block); end

  def docker_config(elem_name = T.unsafe(nil), &block); end
  def docker_configs; end

  sig { returns(T.untyped) }
  def serialize; end
end

class Kuby::Kubernetes::Spec
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def initialize(environment); end

  def add_plugin(plugin_name, &block); end

  sig { returns(T.untyped) }
  def after_configuration; end

  sig { returns(T.untyped) }
  def after_deploy; end

  sig { returns(T.untyped) }
  def before_deploy; end

  def check_dependencies!(plugins = T.unsafe(nil)); end
  def configure_plugin(plugin_name, &block); end
  def deploy(tag = T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def docker; end

  sig { returns(T.untyped) }
  def docker_images; end

  def environment; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def namespace(&block); end

  def plugin(plugin_name); end
  def plugins; end
  def provider(provider_name = T.unsafe(nil), &block); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def registry_secret(&block); end

  sig { returns(T.untyped) }
  def resources; end

  sig { returns(T.untyped) }
  def rollback; end

  sig { returns(T.untyped) }
  def selector_app; end

  def setup(only: T.unsafe(nil)); end
  def tag; end
end

module Kuby::Middleware; end

class Kuby::Middleware::HealthCheck
  def initialize(app); end

  def app; end
  def call(env); end
end

class Kuby::MissingConfigError < ::StandardError; end

class Kuby::Plugin
  def initialize(environment); end

  sig { returns(T.untyped) }
  def after_configuration; end

  def after_deploy(manifest); end

  sig { returns(T.untyped) }
  def after_setup; end

  def before_deploy(manifest); end

  sig { returns(T.untyped) }
  def before_setup; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def configure(&block); end

  sig { returns(T.untyped) }
  def docker_images; end

  def environment; end

  sig { returns(T.untyped) }
  def remove; end

  sig { returns(T.untyped) }
  def resources; end

  sig { returns(T.untyped) }
  def setup; end

  private

  sig { returns(T.untyped) }
  def after_initialize; end

  class << self
    sig { returns(T.untyped) }
    def dependencies; end

    def depends_on(dependable_name, *constraints); end

    sig { returns(T.untyped) }
    def task_dirs; end
  end
end

class Kuby::PluginRegistry
  include ::Enumerable
  include Enumerable

  sig { params(block: T.untyped).returns(T.untyped) }
  def each(&block); end

  def find(plugin_name, environment: T.unsafe(nil)); end
  def register(plugin_name, plugin_klass, environment: T.unsafe(nil)); end

  private

  sig { returns(T.untyped) }
  def plugins; end
end

Kuby::PluginRegistry::ANY = T.let(T.unsafe(nil), String)
module Kuby::Plugins; end

class Kuby::Plugins::NginxIngress < ::Kuby::Plugin
  sig { params(block: T.untyped).returns(T.untyped) }
  def configure(&block); end

  sig { returns(T.untyped) }
  def namespace; end

  sig { returns(T.untyped) }
  def service_name; end

  sig { returns(T.untyped) }
  def setup; end

  private

  sig { returns(T.untyped) }
  def after_initialize; end

  sig { returns(T.untyped) }
  def already_deployed?; end

  sig { returns(T.untyped) }
  def kubernetes_cli; end
end

class Kuby::Plugins::NginxIngress::Config
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def provider(*args); end
end

Kuby::Plugins::NginxIngress::DEFAULT_PROVIDER = T.let(T.unsafe(nil), String)
Kuby::Plugins::NginxIngress::NAMESPACE = T.let(T.unsafe(nil), String)
Kuby::Plugins::NginxIngress::SERVICE_NAME = T.let(T.unsafe(nil), String)
Kuby::Plugins::NginxIngress::SETUP_RESOURCES = T.let(T.unsafe(nil), Array)
Kuby::Plugins::NginxIngress::VERSION = T.let(T.unsafe(nil), String)
module Kuby::Plugins::RailsApp; end

class Kuby::Plugins::RailsApp::AssetCopyTask
  sig { params(to: T.untyped, from: T.untyped).void }
  def initialize(to:, from:); end

  def dest_path; end

  sig { returns(T.untyped) }
  def run; end

  def source_path; end

  private

  sig { returns(T.untyped) }
  def copy_new_assets; end

  sig { returns(T.untyped) }
  def current_dir; end

  sig { returns(T.untyped) }
  def delete_old_assets; end

  def parse_ts(ts); end
  def try_parse_ts(ts); end

  sig { returns(T.untyped) }
  def ts_dir; end
end

Kuby::Plugins::RailsApp::AssetCopyTask::KEEP = T.let(T.unsafe(nil), Integer)
Kuby::Plugins::RailsApp::AssetCopyTask::TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)

class Kuby::Plugins::RailsApp::Assets < ::Kuby::Plugin
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def asset_path(*args); end
  def asset_url(*args); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def configure(&block); end

  def configure_ingress(ingress, hostname); end

  sig { returns(T.untyped) }
  def copy_task; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def deployment(&block); end

  sig { returns(T.untyped) }
  def docker; end

  sig { returns(T.untyped) }
  def docker_images; end

  sig { returns(T.untyped) }
  def image; end

  sig { returns(T.untyped) }
  def kubernetes; end

  sig { returns(T.untyped) }
  def namespace; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def nginx_config(&block); end

  def packs_url(*args); end

  sig { returns(T.untyped) }
  def resources; end

  sig { returns(T.untyped) }
  def role; end

  sig { returns(T.untyped) }
  def selector_app; end

  sig { params(block: T.untyped).returns(T.untyped) }
  def service(&block); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def service_account(&block); end

  private

  sig { returns(T.untyped) }
  def dockerfile; end
end

Kuby::Plugins::RailsApp::Assets::NGINX_IMAGE = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Assets::NGINX_MOUNT_PATH = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Assets::NGINX_PORT = T.let(T.unsafe(nil), Integer)
Kuby::Plugins::RailsApp::Assets::RAILS_MOUNT_PATH = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Assets::ROLE = T.let(T.unsafe(nil), String)

class Kuby::Plugins::RailsApp::AssetsImage < ::Kuby::Docker::Image
  def initialize(base_image, dockerfile, registry_index_url = T.unsafe(nil), main_tag = T.unsafe(nil), alias_tags = T.unsafe(nil)); end

  def base_image; end
  def build(build_args = T.unsafe(nil), docker_args = T.unsafe(nil), context: T.unsafe(nil), cache_from: T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def current_version; end

  sig { returns(T.untyped) }
  def new_version; end

  sig { returns(T.untyped) }
  def previous_version; end

  def pull(tag); end
  def push(tag); end

  private

  def annotate_tag(tag); end
  def duplicate_with_annotated_tags(image); end
end

module Kuby::Plugins::RailsApp::CRDB; end

class Kuby::Plugins::RailsApp::CRDB::Plugin < ::Kuby::Plugin
  def initialize(environment, configs); end

  def add_client_user(username, &block); end
  def after_configuration; end
  def base_name; end
  def bootstrap; end
  def ca_cert; end
  def client_certs; end
  def client_username; end
  def cluster_issuer; end
  def configs; end
  def configure_client_user(username, &block); end
  def configure_container(container); end
  def configure_pod_spec(pod_spec); end
  def database(&block); end
  def environment; end
  def host; end
  def issuer; end
  def kubernetes; end
  def kubernetes_cli; end
  def name; end
  def node_cert; end
  def provider; end
  def rails_app; end
  def resources; end
  def rewritten_configs; end
  def slugify(str); end
  def storage(amount); end

  private

  def config; end
end

Kuby::Plugins::RailsApp::CRDB::Plugin::BOOTSTRAP_TIMEOUT_INTERVAL = T.let(T.unsafe(nil), Integer)
Kuby::Plugins::RailsApp::CRDB::Plugin::BOOTSTRAP_TIMEOUT_TOTAL = T.let(T.unsafe(nil), Integer)
Kuby::Plugins::RailsApp::CRDB::Plugin::CLIENT_PERMISSIONS = T.let(T.unsafe(nil), Array)
Kuby::Plugins::RailsApp::CRDB::Plugin::ROLE = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::CRDB::Plugin::VERSION = T.let(T.unsafe(nil), String)

class Kuby::Plugins::RailsApp::Database
  def initialize(rails_app); end

  def adapter_name; end
  def plugin; end
  def plugin_name; end
  def rails_app; end

  private

  def db_config; end
  def db_config_path; end
  def db_config_paths; end
  def db_config_pattern; end
  def db_configs; end

  class << self
    def get(rails_app); end
    def get_adapter(adapter_name); end
  end
end

Kuby::Plugins::RailsApp::Database::ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

class Kuby::Plugins::RailsApp::Plugin < ::Kuby::Plugin
  include ::KubeDSL::ValueFields::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods

  def initialize(environment); end

  def after_configuration; end
  def app_secrets(&block); end
  def asset_path(*args); end
  def asset_url(*args); end
  def before_deploy(manifest); end
  def config_map(&block); end
  def configure(&block); end
  def database(&block); end
  def database_host; end
  def deployment(&block); end
  def docker; end
  def env(&block); end
  def hostname(*args); end
  def ingress(&block); end
  def kubernetes; end
  def manage_database(*args); end
  def manage_database?(*args); end
  def master_key; end
  def namespace; end
  def packs_url(*args); end
  def replicas(*args); end
  def resources; end
  def role; end
  def root(*args); end
  def selector_app; end
  def service(&block); end
  def service_account(&block); end
  def tls_enabled(*args); end
end

Kuby::Plugins::RailsApp::Plugin::DEFAULT_ASSET_PATH = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Plugin::DEFAULT_ASSET_URL = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Plugin::DEFAULT_HOSTNAME = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Plugin::DEFAULT_PACKS_URL = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Plugin::ENV_EXCLUDE = T.let(T.unsafe(nil), Array)
Kuby::Plugins::RailsApp::Plugin::ENV_SECRETS = T.let(T.unsafe(nil), Array)
Kuby::Plugins::RailsApp::Plugin::MASTER_KEY_VAR = T.let(T.unsafe(nil), String)
Kuby::Plugins::RailsApp::Plugin::WEB_ROLE = T.let(T.unsafe(nil), String)

class Kuby::Plugins::RailsApp::RewriteDbConfig
  def apply_to(dockerfile); end
end

class Kuby::Plugins::RailsApp::Sqlite < ::Kuby::Plugin
  def initialize(environment, *_); end

  sig { returns(T.untyped) }
  def after_configuration; end

  sig { returns(T.untyped) }
  def bootstrap; end

  def configure_pod_spec(_pod_spec); end
  def environment; end

  sig { returns(T.untyped) }
  def name; end

  def password(_password); end
  def user(_user); end
end

class Kuby::Plugins::RailsApp::UnsupportedDatabaseError < ::StandardError; end
class Kuby::Plugins::System < ::Kuby::Plugin; end
class Kuby::Railtie < ::Rails::Railtie; end

class Kuby::Tasks
  def initialize(environment); end

  def build(build_args = T.unsafe(nil), docker_args = T.unsafe(nil), only: T.unsafe(nil), ignore_missing_args: T.unsafe(nil), context: T.unsafe(nil), cache_from_latest: T.unsafe(nil)); end
  def deploy(tag = T.unsafe(nil)); end
  def environment; end

  sig { params(cmd: T.untyped).returns(T.untyped) }
  def kubectl(*cmd); end

  def list_plugins(all: T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def list_rake_tasks; end

  def print_dockerfiles(only: T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def print_images; end

  sig { returns(T.untyped) }
  def print_kubeconfig; end

  def print_resources(kind = T.unsafe(nil), name_pattern = T.unsafe(nil)); end
  def push(only: T.unsafe(nil)); end
  def push_image(image); end

  sig { returns(T.untyped) }
  def remote_console; end

  sig { returns(T.untyped) }
  def remote_dbconsole; end

  def remote_exec(cmd); end

  sig { returns(T.untyped) }
  def remote_logs; end

  sig { returns(T.untyped) }
  def remote_restart; end

  sig { returns(T.untyped) }
  def remote_shell; end

  sig { returns(T.untyped) }
  def remote_status; end

  def remote_system(cmd); end
  def remove_plugin(name); end

  sig { returns(T.untyped) }
  def rollback; end

  def run_rake_tasks(tasks); end
  def setup(only: T.unsafe(nil)); end

  private

  def check_build_args(build_args); end
  def check_platform(docker_args); end

  sig { returns(T.untyped) }
  def docker; end

  sig { returns(T.untyped) }
  def docker_cli; end

  sig { returns(T.untyped) }
  def get_first_pod; end

  sig { returns(T.untyped) }
  def helm_cli; end

  sig { returns(T.untyped) }
  def kubernetes; end

  sig { returns(T.untyped) }
  def kubernetes_cli; end

  sig { returns(T.untyped) }
  def match_labels; end

  sig { returns(T.untyped) }
  def namespace; end

  def perform_docker_login_if_necessary(image); end

  sig { returns(T.untyped) }
  def rails_app; end
end

class Kuby::TrailingHash < ::Hash
  sig { params(block: T.untyped).returns(T.untyped) }
  def each(&block); end
end

class Kuby::UndefinedEnvironmentError < ::StandardError; end

module Kuby::Utils
  class << self
    sig { params(args: T.untyped).returns(T.untyped) }
    def which(*args); end
  end
end

module Kuby::Utils::SemVer
  class << self
    sig { params(strs: T.untyped).returns(T.untyped) }
    def parse_constraints(*strs); end

    def parse_version(str); end
  end
end

class Kuby::Utils::SemVer::Constraint
  def initialize(operator, version); end

  def operator; end
  def satisfied_by?(other_version); end

  sig { returns(T.untyped) }
  def to_s; end

  def version; end

  class << self
    def parse(str); end
  end
end

Kuby::Utils::SemVer::Constraint::OPERATOR_INVERSE = T.let(T.unsafe(nil), Hash)
Kuby::Utils::SemVer::Constraint::OPERATOR_MAP = T.let(T.unsafe(nil), Hash)

class Kuby::Utils::SemVer::ConstraintSet
  def initialize(constraints); end

  def constraints; end
  def satisfied_by?(version); end

  sig { returns(T.untyped) }
  def to_s; end

  class << self
    sig { params(arr: T.untyped).returns(T.untyped) }
    def parse(*arr); end
  end
end

class Kuby::Utils::SemVer::Version
  include ::Comparable
  include Comparable

  def initialize(major, minor, patch); end

  def <=>(other); end
  def major; end
  def minor; end
  def patch; end

  sig { returns(T.untyped) }
  def to_a; end

  sig { returns(T.untyped) }
  def to_s; end

  class << self
    def parse(str, default: T.unsafe(nil)); end
  end
end

class Kuby::Utils::Table
  def initialize(headers, rows); end

  def headers; end
  def rows; end

  sig { returns(T.untyped) }
  def to_s; end

  private

  def col_width_at(idx); end

  sig { returns(T.untyped) }
  def col_widths; end

  def make_row(values); end
end

module Kuby::Utils::Which
  extend ::Kuby::Utils::Which
  extend self

  def which(program, path = T.unsafe(nil)); end
end

Kuby::VERSION = T.let(T.unsafe(nil), String)

class KubyGenerator < ::Rails::Generators::Base
  sig { returns(T.untyped) }
  def create_config_file; end

  sig { returns(T.untyped) }
  def create_dockerignore; end

  sig { returns(T.untyped) }
  def create_initializer_file; end

  private

  sig { returns(T.untyped) }
  def app_name; end
end
