# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gli` gem.
# Please instead update this file by running `bin/tapioca gem gli`.

module GLI
  include ::GLI::DSL
  include ::GLI::AppSupport
  include ::GLI::App

  class << self
    def included(klass); end
    def run(*args); end
  end
end

class GLI::AmbiguousCommand < ::GLI::BadCommandLine; end

module GLI::App
  include ::GLI::DSL
  include ::GLI::AppSupport

  def accept(object, &block); end
  def arguments(handling_strategy); end
  def around(&a_proc); end
  def autocomplete_commands(boolean); end
  def commands_from(path); end
  def config_file(filename); end
  def default_command(command); end
  def exit_now!(message, exit_code = T.unsafe(nil)); end
  def help_now!(message = T.unsafe(nil)); end
  def hide_commands_without_desc(hide = T.unsafe(nil)); end
  def on_error(&a_proc); end
  def post(&a_proc); end
  def pre(&a_proc); end
  def preserve_argv(preserve = T.unsafe(nil)); end
  def program_desc(description = T.unsafe(nil)); end
  def program_long_desc(description = T.unsafe(nil)); end
  def program_name(override = T.unsafe(nil)); end
  def skips_around; end
  def skips_post; end
  def skips_pre; end
  def sort_help(sort_type); end
  def subcommand_option_handling(handling_strategy); end
  def synopsis_format(format); end
  def use_openstruct(use_openstruct); end
  def version(version); end
  def wrap_help_text(wrap_type); end

  private

  def load_commands(path); end
end

module GLI::AppSupport
  def accepts; end
  def argument_handling_strategy; end
  def around_blocks; end
  def autocomplete; end
  def clear_nexts; end
  def commands; end
  def commands_declaration_order; end
  def config_file_name; end
  def context_description; end
  def error_device=(e); end
  def exe_name; end
  def flags; end
  def get_default_command; end
  def help_sort_type; end
  def help_text_wrap_type; end
  def override_command_defaults(command_list, config); end
  def override_default(tokens, config); end
  def override_defaults_based_on_config(config); end
  def parse_config; end
  def post_block; end
  def pre_block; end
  def reset; end
  def run(args); end
  def stderr; end
  def subcommand_option_handling_strategy; end
  def switches; end
  def synopsis_format_type; end
  def version_string; end

  private

  def add_help_switch_if_needed(target); end
  def call_command(parsing_result); end
  def error_message(ex); end
  def handle_exception(ex, command); end
  def no_message_given?(ex); end
  def output_error_message(ex); end
  def proceed?(parsing_result); end
  def regular_error_handling?(ex); end

  class << self
    def included(klass); end
  end
end

class GLI::Argument
  def initialize(name, options = T.unsafe(nil)); end

  def multiple?; end
  def name; end
  def optional?; end
  def options; end
end

class GLI::BadCommandLine < ::StandardError
  include ::GLI::StandardException

  def exit_code; end
end

class GLI::Command < ::GLI::CommandLineToken
  include ::GLI::DSL
  include ::GLI::CommandSupport

  def initialize(options); end

  def action(&block); end
  def default_command(command_name); end
  def default_desc(desc); end
  def example(example_invocation, options = T.unsafe(nil)); end
  def has_option?(option); end
  def name_for_help; end

  class << self
    def name_as_string(name, negatable = T.unsafe(nil)); end
  end
end

GLI::Command::PARENT = T.let(T.unsafe(nil), GLI::Command::ParentKey)

class GLI::Command::ParentKey
  def to_sym; end
end

class GLI::CommandException < ::GLI::BadCommandLine
  def initialize(message, command_in_context, exit_code = T.unsafe(nil)); end

  def command_in_context; end
  def exit_code; end
end

class GLI::CommandFinder
  def initialize(commands, options = T.unsafe(nil)); end

  def find_command(name); end
  def options; end
  def options=(_arg0); end

  private

  def commands_with_aliases; end
  def commands_with_aliases=(_arg0); end
  def expand_with_aliases(commands); end
  def find_command_by_partial_name(commands_with_aliases, command_to_match); end
end

GLI::CommandFinder::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class GLI::CommandLineOption < ::GLI::CommandLineToken
  def initialize(names, options = T.unsafe(nil)); end

  def associated_command; end
  def associated_command=(_arg0); end
  def default_value; end
  def default_value=(_arg0); end

  class << self
    def name_as_string(name, negatable = T.unsafe(nil)); end
  end
end

class GLI::CommandLineToken
  def initialize(names, description, long_description = T.unsafe(nil)); end

  def <=>(other); end
  def aliases; end
  def description; end
  def long_description; end
  def name; end
  def names_and_aliases; end

  private

  def all_forms(joiner = T.unsafe(nil)); end
  def all_forms_a; end
  def negatable?; end
  def parse_names(names); end
end

class GLI::CommandOptionBlockParser < ::GLI::GLIOptionBlockParser
  def command=(command_being_parsed); end

  protected

  def break_on_non_option?; end
  def do_parse(args); end
end

module GLI::CommandSupport
  def arg_name(d, options = T.unsafe(nil)); end
  def arguments; end
  def arguments_description; end
  def arguments_options; end
  def commands; end
  def commands_declaration_order; end
  def context_description; end
  def default_description; end
  def default_value(d); end
  def desc(d); end
  def examples; end
  def execute(global_options, options, arguments); end
  def flag(*names); end
  def flags; end
  def get_default_command; end
  def has_action?; end
  def long_desc(d); end
  def names; end
  def nodoc; end
  def parent; end
  def parent=(_arg0); end
  def skips_around; end
  def skips_post; end
  def skips_pre; end
  def switch(*names); end
  def switches; end
  def topmost_ancestor; end

  private

  def am_subcommand?; end
  def generate_error_action(arguments); end
  def get_action(arguments); end
  def have_subcommands?; end
  def send_declarations_to_parent?; end
end

module GLI::Commands; end

class GLI::Commands::CompoundCommand < ::GLI::Command
  def initialize(base, configuration, options = T.unsafe(nil)); end

  def execute(global_options, options, arguments); end

  private

  def check_for_unknown_commands!(base, command_names); end

  class << self
    def find_command(base, name); end
  end
end

class GLI::Commands::Doc < ::GLI::Command
  def initialize(app); end

  def document(document_listener); end
  def nodoc; end

  private

  def any_commands?(command); end
  def any_options?(context); end
  def by_name; end
  def call_command_method_being_backwards_compatible(document_listener, command); end
  def command_flags(command); end
  def command_switches(command); end
  def document_commands(document_listener, context); end
  def document_flags_and_switches(document_listener, flags, switches); end
  def format_class(format_name); end
end

class GLI::Commands::Doc::DocumentListener
  def initialize(global_options, options, arguments, app); end

  def beginning; end
  def command(name, aliases, desc, long_desc, arg_name, arg_options); end
  def commands; end
  def default_command(name); end
  def end_command(name); end
  def end_commands; end
  def end_options; end
  def ending; end
  def flag(name, aliases, desc, long_desc, default_value, arg_name, must_match, type); end
  def options; end
  def program_desc(desc); end
  def program_long_desc(desc); end
  def switch(name, aliases, desc, long_desc, negatable); end
  def version(version); end

  private

  def abstract!; end
end

GLI::Commands::Doc::FORMATS = T.let(T.unsafe(nil), Hash)

class GLI::Commands::Help < ::GLI::Command
  def initialize(app, output = T.unsafe(nil), error = T.unsafe(nil)); end

  def skips_around; end
  def skips_post; end
  def skips_pre; end

  private

  def show_help(global_options, options, arguments, out, error); end

  class << self
    def skips_around=(skips_around); end
    def skips_post=(skips_post); end
    def skips_pre=(skips_pre); end
  end
end

module GLI::Commands::HelpModules; end

class GLI::Commands::HelpModules::ArgNameFormatter
  def format(arguments_description, arguments_options, arguments); end
  def format_argname(arguments_description, arguments_options); end
  def format_arguments(arguments); end
end

class GLI::Commands::HelpModules::CommandFinder
  def initialize(app, arguments, error); end

  def find_command(name); end
  def last_found_command; end
  def last_unknown_command; end
  def squelch_stderr=(_arg0); end

  private

  def find_command_from_base(command_name, base); end
  def unknown_command?(command, name, error); end
end

class GLI::Commands::HelpModules::CommandHelpFormat
  def initialize(command, app, sorter, synopsis_formatter_class, wrapper_class = T.unsafe(nil)); end

  def format; end

  private

  def flags_and_switches(command, app); end
  def format_examples(command); end
  def format_subcommands(command); end
end

GLI::Commands::HelpModules::CommandHelpFormat::COMMAND_HELP = T.let(T.unsafe(nil), ERB)

class GLI::Commands::HelpModules::CompactSynopsisFormatter < ::GLI::Commands::HelpModules::FullSynopsisFormatter
  protected

  def sub_options_doc(sub_options); end
end

class GLI::Commands::HelpModules::FullSynopsisFormatter
  def initialize(app, flags_and_switches); end

  def synopses_for_command(command); end

  protected

  def sub_options_doc(sub_options); end

  private

  def basic_usage(command); end
  def command_with_subcommand_usage(command, sub, is_default_command); end
  def global_flags_and_switches; end
  def path_to_command(command); end
  def sorted_synopses(command); end
end

class GLI::Commands::HelpModules::GlobalHelpFormat
  def initialize(app, sorter, wrapper_class); end

  def format; end

  private

  def global_flags_and_switches; end
  def usage_string; end
end

GLI::Commands::HelpModules::GlobalHelpFormat::GLOBAL_HELP = T.let(T.unsafe(nil), ERB)

class GLI::Commands::HelpModules::HelpCompletionFormat
  def initialize(app, command_finder, args); end

  def format; end
end

class GLI::Commands::HelpModules::ListFormatter
  def initialize(list, wrapper_class = T.unsafe(nil)); end

  def output(output_device); end
end

class GLI::Commands::HelpModules::OneLineWrapper
  def initialize(width, indent); end

  def wrap(text); end
end

class GLI::Commands::HelpModules::OptionsFormatter
  def initialize(flags_and_switches, sorter, wrapper_class); end

  def format; end

  private

  def description_with_default(option); end
  def option_names_for_help_string(option, arg_name = T.unsafe(nil)); end
end

class GLI::Commands::HelpModules::TTYOnlyWrapper
  def initialize(width, indent); end

  def wrap(text); end
end

class GLI::Commands::HelpModules::TerminalSynopsisFormatter
  def initialize(app, flags_and_switches); end

  def synopses_for_command(command); end
end

class GLI::Commands::HelpModules::TextWrapper
  def initialize(width, indent); end

  def wrap(text); end
end

class GLI::Commands::HelpModules::VerbatimWrapper
  def initialize(width, indent); end

  def wrap(text); end
end

class GLI::Commands::RdocDocumentListener
  def initialize(global_options, options, arguments, app); end

  def beginning; end
  def command(name, aliases, desc, long_desc, arg_name, arg_options); end
  def commands; end
  def default_command(name); end
  def end_command(name); end
  def end_commands; end
  def end_options; end
  def ending; end
  def flag(name, aliases, desc, long_desc, default_value, arg_name, must_match, type); end
  def options; end
  def program_desc(desc); end
  def program_long_desc(desc); end
  def switch(name, aliases, desc, long_desc, negatable); end
  def version(version); end

  private

  def add_dashes(name); end
end

GLI::Commands::SORTERS = T.let(T.unsafe(nil), Hash)
GLI::Commands::SYNOPSIS_FORMATTERS = T.let(T.unsafe(nil), Hash)
GLI::Commands::WRAPPERS = T.let(T.unsafe(nil), Hash)

class GLI::CustomExit < ::StandardError
  include ::GLI::StandardException

  def initialize(message, exit_code); end

  def exit_code; end
end

module GLI::DSL
  def arg(name, options = T.unsafe(nil)); end
  def arg_name(name, options = T.unsafe(nil)); end
  def c(*names); end
  def clear_nexts; end
  def command(*names); end
  def command_missing(&block); end
  def d(description); end
  def default_value(val); end
  def desc(description); end
  def f(*names); end
  def flag(*names); end
  def flags_declaration_order; end
  def long_desc(long_desc); end
  def s(*names); end
  def switch(*names); end
  def switches_declaration_order; end

  private

  def extract_options(names); end
  def verify_unused(names); end
  def verify_unused_in_option(name, option_like, type); end
end

class GLI::Flag < ::GLI::CommandLineOption
  def initialize(names, options); end

  def all_forms(joiner = T.unsafe(nil)); end
  def argument_name; end
  def arguments_for_option_parser; end
  def default_value; end
  def multiple?; end
  def must_match; end
  def required?; end
  def safe_default_value; end
  def type; end
end

class GLI::GLIOptionBlockParser
  def initialize(option_parser_factory, exception_klass_or_block); end

  def parse!(args); end

  protected

  def do_parse(args); end
end

class GLI::GLIOptionParser
  def initialize(commands, flags, switches, accepts, options = T.unsafe(nil)); end

  def options; end
  def options=(_arg0); end
  def parse_options(args); end
end

GLI::GLIOptionParser::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class GLI::GLIOptionParser::GlobalOptionParser
  def initialize(option_parser_factory, command_finder, flags, options = T.unsafe(nil)); end

  def parse!(parsing_result); end

  protected

  def verify_arguments!(arguments, command); end
  def verify_required_options!(flags, command, options); end
end

class GLI::GLIOptionParser::LegacyCommandOptionParser < ::GLI::GLIOptionParser::NormalCommandOptionParser
  def parse!(parsing_result, argument_handling_strategy, autocomplete); end

  private

  def find_subcommand(command, arguments, autocomplete); end
end

class GLI::GLIOptionParser::NormalCommandOptionParser < ::GLI::GLIOptionParser::GlobalOptionParser
  def initialize(accepts); end

  def error_handler; end
  def parse!(parsing_result, argument_handling_strategy, autocomplete); end
end

class GLI::InitConfig < ::GLI::Command
  def initialize(config_file_name, commands, flags, switches); end

  private

  def config_for_command(commands, command_name); end
  def create_config(global_options, options, arguments); end
end

GLI::InitConfig::COMMANDS_KEY = T.let(T.unsafe(nil), String)

class GLI::LegacyCommandOptionBlockParser < ::GLI::CommandOptionBlockParser
  protected

  def break_on_non_option?; end
end

class GLI::MissingRequiredArgumentsException < ::GLI::BadCommandLine
  def initialize(message, command); end

  def command_in_context; end
end

class GLI::OptionParserFactory
  def initialize(flags, switches, accepts); end

  def option_parser; end
  def options_hash; end
  def options_hash_with_defaults_set!; end

  private

  def set_defaults(options_by_name, options_hash); end

  class << self
    def add_help_switches_to_command(option_parser, command); end
    def for_command(command, accepts); end
    def setup_accepts(opts, accepts); end
    def setup_options(opts, tokens, options); end
  end
end

class GLI::OptionParsingResult
  def arguments; end
  def arguments=(_arg0); end
  def command; end
  def command=(_arg0); end
  def command_options; end
  def command_options=(_arg0); end
  def convert_to_openstruct!; end
  def global_options; end
  def global_options=(_arg0); end
  def to_a; end
end

class GLI::Options < ::OpenStruct
  def [](k); end
  def []=(k, v); end
  def map(&block); end
end

class GLI::PreconditionFailed < ::StandardError
  include ::GLI::StandardException

  def exit_code; end
end

class GLI::RequestHelp < ::StandardError
  include ::GLI::StandardException

  def initialize(command_in_context); end

  def command_in_context; end
  def exit_code; end
end

module GLI::StandardException
  def exit_code; end
end

class GLI::Switch < ::GLI::CommandLineOption
  def initialize(names, options = T.unsafe(nil)); end

  def arguments_for_option_parser; end
  def default_value; end
  def default_value=(_arg0); end
  def negatable; end
  def negatable?; end
  def required?; end
end

class GLI::Terminal
  def command_exists?(command); end
  def make_unsafe!; end
  def size; end

  class << self
    def command_exists?(command); end
    def default_size; end
    def default_size=(size); end
    def instance; end
    def jruby?; end
    def run_command(command); end
    def solaris?; end
  end
end

GLI::Terminal::SIZE_DETERMINERS = T.let(T.unsafe(nil), Array)
class GLI::UnknownCommand < ::GLI::BadCommandLine; end
class GLI::UnknownCommandArgument < ::GLI::CommandException; end
class GLI::UnknownGlobalArgument < ::GLI::BadCommandLine; end
GLI::VERSION = T.let(T.unsafe(nil), String)
