# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kubernetes-cli` gem.
# Please instead update this file by running `bin/tapioca gem kubernetes-cli`.

# typed: strong
class KubernetesCLI
  extend T::Sig

  def initialize(kubeconfig_path, executable = T.unsafe(nil)); end

  sig { params(block: AfterCallback).void }
  def after_execute(&block); end

  def annotate(type, namespace, name, annotations, overwrite: T.unsafe(nil)); end

  sig { returns(String) }
  def api_resources; end

  def apply(res, dry_run: T.unsafe(nil)); end
  def apply_uri(uri, dry_run: T.unsafe(nil)); end

  sig { params(block: BeforeCallback).void }
  def before_execute(&block); end

  sig { returns(String) }
  def current_context; end

  def delete_object(type, namespace, name); end
  def delete_objects(type, namespace, match_labels = T.unsafe(nil)); end
  def exec_cmd(container_cmd, namespace, pod, tty = T.unsafe(nil), container = T.unsafe(nil), out_file = T.unsafe(nil)); end
  def executable; end
  def get_object(type, namespace, name); end
  def get_objects(type, namespace, match_labels = T.unsafe(nil)); end
  def kubeconfig_path; end

  sig { returns(T.nilable(Process::Status)) }
  def last_status; end

  def logtail(namespace, selector, follow: T.unsafe(nil)); end

  sig { params(block: T.proc.params(last_status: Process::Status).void).void }
  def on_last_status_failure(&block); end

  def patch_object(type, namespace, name, patch_data, patch_type = T.unsafe(nil)); end
  def restart_deployment(namespace, deployment); end
  def run_cmd(cmd); end

  sig { returns(T.any(StringIO, IO)) }
  def stderr; end

  def stderr=(new_stderr); end

  sig { returns(T.any(StringIO, IO)) }
  def stdout; end

  def stdout=(new_stdout); end
  def system_cmd(container_cmd, namespace, pod, tty = T.unsafe(nil), container = T.unsafe(nil)); end

  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def version; end

  sig { params(block: T.proc.params(last_status: Process::Status).void).void }
  def with_last_status(&block); end

  def with_pipes(out = T.unsafe(nil), err = T.unsafe(nil), &block); end

  private

  def backticks(cmd); end
  def backticks_default(cmd); end
  def backticks_open3(cmd); end

  sig { returns(T::Array[String]) }
  def base_cmd; end

  sig { returns(T::Hash[String, String]) }
  def env; end

  def execc(cmd); end
  def last_status=(status); end
  def open3_w(env, cmd, opts = T.unsafe(nil), &block); end
  def run_after_callbacks(cmd); end
  def run_before_callbacks(cmd); end
  def systemm(cmd); end
  def systemm_default(cmd); end
  def systemm_open3(cmd); end

  AfterCallback = T.type_alias {
  T.proc.params(cmd: T::Array[String], last_status: Process::Status).void
}
  BeforeCallback = T.type_alias {
  T.proc.params(cmd: T::Array[String]).void
}
end

class KubernetesCLI::AnnotateResourceError < ::KubernetesCLI::KubernetesError; end
class KubernetesCLI::DeleteResourceError < ::KubernetesCLI::KubernetesError; end
class KubernetesCLI::GetResourceError < ::KubernetesCLI::KubernetesError; end
class KubernetesCLI::GetVersionError < ::KubernetesCLI::KubernetesError; end

class KubernetesCLI::InvalidResourceError < ::KubernetesCLI::KubernetesError
  extend T::Sig

  sig { params(args: T.untyped).void }
  def initialize(*args); end

  def resource; end
  def resource=(_arg0); end
end

class KubernetesCLI::InvalidResourceUriError < ::KubernetesCLI::KubernetesError
  extend T::Sig

  sig { params(args: T.untyped).void }
  def initialize(*args); end

  def resource_uri; end
  def resource_uri=(_arg0); end
end

class KubernetesCLI::KubernetesError < ::StandardError; end
class KubernetesCLI::PatchResourceError < ::KubernetesCLI::KubernetesError; end
KubernetesCLI::STATUS_KEY = T.let(T.unsafe(nil), Symbol)
KubernetesCLI::STDERR_KEY = T.let(T.unsafe(nil), Symbol)
KubernetesCLI::STDOUT_KEY = T.let(T.unsafe(nil), Symbol)
