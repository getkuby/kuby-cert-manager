# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `jsonpath` gem.
# Please instead update this file by running `bin/tapioca gem jsonpath`.

class JsonPath
  def initialize(path, opts = T.unsafe(nil)); end

  def [](obj_or_str, mode = T.unsafe(nil)); end
  def enum_on(obj_or_str, mode = T.unsafe(nil)); end
  def find_matching_brackets(token, scanner); end
  def first(obj_or_str, *args); end
  def join(join_path); end
  def on(obj_or_str, opts = T.unsafe(nil)); end
  def path; end
  def path=(_arg0); end

  private

  def deep_clone; end

  class << self
    def construct_path(table_row); end
    def fetch_all_path(obj); end
    def find_path(obj, root_key, all_paths, is_array = T.unsafe(nil)); end
    def for(obj_or_str); end
    def on(obj_or_str, path, opts = T.unsafe(nil)); end
    def process_object(obj_or_str, opts = T.unsafe(nil)); end
  end
end

JsonPath::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module JsonPath::Dig
  def dig(context, *keys); end
  def dig_as_hash(context, keys); end
  def dig_one(context, k); end
  def yield_if_diggable(context, k, &blk); end
end

class JsonPath::Enumerable
  include ::Enumerable
  include ::JsonPath::Dig

  def initialize(path, object, mode, options = T.unsafe(nil)); end

  def each(context = T.unsafe(nil), key = T.unsafe(nil), pos = T.unsafe(nil), &blk); end

  private

  def ensure_exclusive_end_index(value); end
  def filter_context(context, keys); end
  def handle_question_mark(sub_path, node, pos, &blk); end
  def handle_wildecard(node, expr, _context, _key, pos, &blk); end
  def process_function_or_literal(exp, default = T.unsafe(nil)); end
  def yield_value(blk, context, key); end
end

JsonPath::PATH_ALL = T.let(T.unsafe(nil), String)

class JsonPath::Parser
  include ::JsonPath::Dig

  def initialize(node, options); end

  def construct_expression_map(exps); end
  def parse(exp); end
  def parse_exp(exp); end

  private

  def bool_or_exp(b); end
  def check_parenthesis_count(exp); end
  def parse_parentheses(str); end
  def parse_regex(t); end
end

JsonPath::Parser::REGEX = T.let(T.unsafe(nil), Regexp)

class JsonPath::Proxy
  def initialize(obj); end

  def compact(path = T.unsafe(nil)); end
  def compact!(path = T.unsafe(nil)); end
  def delete(path = T.unsafe(nil)); end
  def delete!(path = T.unsafe(nil)); end
  def gsub(path, replacement = T.unsafe(nil), &replacement_block); end
  def gsub!(path, replacement = T.unsafe(nil), &replacement_block); end
  def obj; end
  def to_hash; end

  private

  def _compact(obj, path); end
  def _deep_copy; end
  def _delete(obj, path); end
  def _gsub(obj, path, replacement); end
  def _remove(obj); end
end

JsonPath::VERSION = T.let(T.unsafe(nil), String)
