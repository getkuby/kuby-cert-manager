# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kuby-crdb` gem.
# Please instead update this file by running `bin/tapioca gem kuby-crdb`.

module Kuby
  class << self
    def define(name, &block); end
    def definition; end
    def dependables; end
    def distros; end
    def env; end
    def env=(env_name); end
    def environment(name = T.unsafe(nil)); end
    def load!(config_file = T.unsafe(nil)); end
    def load_rake_tasks!; end
    def logger; end
    def logger=(_arg0); end
    def packages; end
    def plugins; end
    def providers; end
    def register_dependable(name, version_or_callable); end
    def register_distro(distro_name, distro_klass); end
    def register_package(package_name, package_def = T.unsafe(nil)); end
    def register_plugin(*args, **kwargs); end
    def register_provider(provider_name, provider_klass); end
  end
end

module Kuby::CRDB
  extend ::Kuby::CRDB::Entrypoint
end

class Kuby::CRDB::APIResourcesError < ::Kuby::CRDB::CRDBError; end
class Kuby::CRDB::CRDBError < ::StandardError; end
Kuby::CRDB::CRDB_OPERATOR_VERSION = T.let(T.unsafe(nil), String)
module Kuby::CRDB::DSL; end
module Kuby::CRDB::DSL::CRDB; end
module Kuby::CRDB::DSL::CRDB::V1alpha1; end

class Kuby::CRDB::DSL::CRDB::V1alpha1::CrdbCluster < ::KubeDSL::DSLObject
  def api_version(*args); end
  def kind_sym; end
  def metadata(*args, &block); end
  def metadata_present?; end
  def serialize; end
  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::CrdbClusterList < ::KubeDSL::DSLObject
  def api_version(*args); end
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end
  def kind_sym; end
  def metadata(*args, &block); end
  def metadata_present?; end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::Spec < ::KubeDSL::DSLObject
  def additional_annotations(&block); end
  def additional_args(*args); end
  def additional_labels(&block); end
  def affinity(*args, &block); end
  def affinity_present?; end
  def cache(*args); end
  def client_tls_secret(*args); end
  def cockroach_db_version(*args); end
  def data_store(*args, &block); end
  def data_store_present?; end
  def grpc_port(*args); end
  def http_port(*args); end
  def image(*args, &block); end
  def image_present?; end
  def kind_sym; end
  def max_sql_memory(*args); end
  def max_unavailable(*args); end
  def min_available(*args); end
  def node_selector(&block); end
  def node_tls_secret(*args); end
  def nodes(*args); end
  def pod_env_variables(*args); end
  def resources(*args, &block); end
  def resources_present?; end
  def serialize; end
  def sql_port(*args); end
  def tls_enabled(*args); end
  def tolerations(*args); end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecAffinity < ::KubeDSL::DSLObject
  def kind_sym; end
  def node_affinity(*args, &block); end
  def node_affinity_present?; end
  def pod_affinity(*args, &block); end
  def pod_affinity_present?; end
  def pod_anti_affinity(*args, &block); end
  def pod_anti_affinity_present?; end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecAffinityNodeAffinity < ::KubeDSL::DSLObject
  def kind_sym; end
  def preferred_during_scheduling_ignored_during_execution(*args); end
  def required_during_scheduling_ignored_during_execution(*args, &block); end
  def required_during_scheduling_ignored_during_execution_present?; end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution < ::KubeDSL::DSLObject
  def kind_sym; end
  def node_selector_terms(*args); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecAffinityPodAffinity < ::KubeDSL::DSLObject
  def kind_sym; end
  def preferred_during_scheduling_ignored_during_execution(*args); end
  def required_during_scheduling_ignored_during_execution(*args); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecAffinityPodAntiAffinity < ::KubeDSL::DSLObject
  def kind_sym; end
  def preferred_during_scheduling_ignored_during_execution(*args); end
  def required_during_scheduling_ignored_during_execution(*args); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStore < ::KubeDSL::DSLObject
  def host_path(*args, &block); end
  def host_path_present?; end
  def kind_sym; end
  def pvc(*args, &block); end
  def pvc_present?; end
  def serialize; end
  def supports_auto_resize(*args); end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStoreHostPath < ::KubeDSL::DSLObject
  def kind_sym; end
  def path(*args); end
  def serialize; end
  def type(*args); end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStorePvc < ::KubeDSL::DSLObject
  def kind_sym; end
  def serialize; end
  def source(*args, &block); end
  def source_present?; end
  def spec(*args, &block); end
  def spec_present?; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStorePvcSource < ::KubeDSL::DSLObject
  def claim_name(*args); end
  def kind_sym; end
  def read_only(*args); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStorePvcSpec < ::KubeDSL::DSLObject
  def access_modes(*args); end
  def data_source(*args, &block); end
  def data_source_present?; end
  def kind_sym; end
  def resources(*args, &block); end
  def resources_present?; end
  def selector(*args, &block); end
  def selector_present?; end
  def serialize; end
  def storage_class_name(*args); end
  def volume_mode(*args); end
  def volume_name(*args); end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStorePvcSpecDataSource < ::KubeDSL::DSLObject
  def api_group(*args); end
  def kind(*args); end
  def kind_sym; end
  def name(*args); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStorePvcSpecResources < ::KubeDSL::DSLObject
  def kind_sym; end
  def limits(&block); end
  def requests(&block); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecDataStorePvcSpecSelector < ::KubeDSL::DSLObject
  def kind_sym; end
  def match_expressions(*args); end
  def match_labels(&block); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecImage < ::KubeDSL::DSLObject
  def kind_sym; end
  def name(*args); end
  def pull_policy(*args); end
  def pull_secret(*args); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::SpecResources < ::KubeDSL::DSLObject
  def kind_sym; end
  def limits(&block); end
  def requests(&block); end
  def serialize; end
end

class Kuby::CRDB::DSL::CRDB::V1alpha1::Status < ::KubeDSL::DSLObject
  def cluster_status(*args); end
  def conditions(*args); end
  def crdbcontainerimage(*args); end
  def kind_sym; end
  def operator_actions(*args); end
  def serialize; end
  def version(*args); end
end

module Kuby::CRDB::Entrypoint
  def crdb_cluster(&block); end
  def crdb_cluster_list(&block); end
end

class Kuby::CRDB::OperatorDeployError < ::Kuby::CRDB::CRDBError; end

class Kuby::CRDB::Plugin < ::Kuby::Plugin
  def setup; end

  private

  def find_operator_rs(depl); end
  def install_operator; end
  def kubernetes_cli; end
  def operator_deployed?; end
  def operator_deployment; end
  def operator_ready?; end
  def provider; end
  def rs_ready?(rs); end
  def upgrade_operator; end
  def wait_for_api_resources; end
  def wait_for_operator; end
end

Kuby::CRDB::Plugin::CRD_URL = T.let(T.unsafe(nil), String)
Kuby::CRDB::Plugin::NAMESPACE = T.let(T.unsafe(nil), String)
Kuby::CRDB::Plugin::OPERATOR_DEPLOYMENT_NAME = T.let(T.unsafe(nil), String)
Kuby::CRDB::Plugin::OPERATOR_URL = T.let(T.unsafe(nil), String)
Kuby::CRDB::Plugin::REPLICA_SET_MATCH_LABELS = T.let(T.unsafe(nil), Hash)
Kuby::CRDB::Plugin::WAIT_INTERVAL = T.let(T.unsafe(nil), Integer)
Kuby::CRDB::Plugin::WAIT_MAX = T.let(T.unsafe(nil), Integer)
Kuby::CRDB::VERSION = T.let(T.unsafe(nil), String)
Kuby::DEFAULT_DB_PASSWORD = T.let(T.unsafe(nil), String)
Kuby::DEFAULT_DB_USER = T.let(T.unsafe(nil), String)
Kuby::DEFAULT_ENV = T.let(T.unsafe(nil), String)
Kuby::VERSION = T.let(T.unsafe(nil), String)
