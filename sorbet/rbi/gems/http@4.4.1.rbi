# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http` gem.
# Please instead update this file by running `bin/tapioca gem http`.

module HTTP
  extend ::HTTP::Chainable

  class << self
    def [](headers); end
  end
end

HTTP::CHARSET_RE = T.let(T.unsafe(nil), Regexp)

module HTTP::Chainable
  def accept(type); end
  def auth(value); end
  def basic_auth(opts); end
  def build_request(*args); end
  def connect(uri, options = T.unsafe(nil)); end
  def cookies(cookies); end
  def default_options; end
  def default_options=(opts); end
  def delete(uri, options = T.unsafe(nil)); end
  def encoding(encoding); end
  def follow(options = T.unsafe(nil)); end
  def get(uri, options = T.unsafe(nil)); end
  def head(uri, options = T.unsafe(nil)); end
  def headers(headers); end
  def nodelay; end
  def options(uri, options = T.unsafe(nil)); end
  def patch(uri, options = T.unsafe(nil)); end
  def persistent(host, timeout: T.unsafe(nil)); end
  def post(uri, options = T.unsafe(nil)); end
  def put(uri, options = T.unsafe(nil)); end
  def request(*args); end
  def through(*proxy); end
  def timeout(options); end
  def trace(uri, options = T.unsafe(nil)); end
  def use(*features); end
  def via(*proxy); end

  private

  def branch(options); end
end

class HTTP::Client
  include ::HTTP::Chainable
  extend ::Forwardable

  def initialize(default_options = T.unsafe(nil)); end

  def build_request(verb, uri, opts = T.unsafe(nil)); end
  def close; end
  def perform(req, options); end
  def persistent?(*args, &block); end
  def request(verb, uri, opts = T.unsafe(nil)); end

  private

  def make_form_data(form); end
  def make_request_body(opts, headers); end
  def make_request_headers(opts); end
  def make_request_uri(uri, opts); end
  def verify_connection!(uri); end
end

HTTP::Client::HTTP_OR_HTTPS_RE = T.let(T.unsafe(nil), Regexp)

class HTTP::Connection
  extend ::Forwardable

  def initialize(req, options); end

  def close; end
  def expired?; end
  def failed_proxy_connect?; end
  def finish_response; end
  def headers(*args, &block); end
  def http_version(*args, &block); end
  def keep_alive?; end
  def proxy_response_headers; end
  def read_headers!; end
  def readpartial(size = T.unsafe(nil)); end
  def send_request(req); end
  def status_code(*args, &block); end

  private

  def read_more(size); end
  def reset_timer; end
  def send_proxy_connect_request(req); end
  def set_keep_alive; end
  def start_tls(req, options); end
end

HTTP::Connection::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)
HTTP::Connection::CLOSE = T.let(T.unsafe(nil), String)
HTTP::Connection::HTTP_1_0 = T.let(T.unsafe(nil), String)
HTTP::Connection::HTTP_1_1 = T.let(T.unsafe(nil), String)
HTTP::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)
class HTTP::ConnectionError < ::HTTP::Error; end

class HTTP::ContentType < ::Struct
  def charset; end
  def charset=(_); end
  def mime_type; end
  def mime_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
    def parse(str); end

    private

    def charset(str); end
    def mime_type(str); end
  end
end

class HTTP::Error < ::StandardError; end

class HTTP::Feature
  def initialize(opts = T.unsafe(nil)); end

  def wrap_request(request); end
  def wrap_response(response); end
end

module HTTP::Features; end

class HTTP::Features::AutoDeflate < ::HTTP::Feature
  def initialize(**_arg0); end

  def deflated_body(body); end
  def method; end
  def wrap_request(request); end
end

class HTTP::Features::AutoDeflate::CompressedBody < ::HTTP::Request::Body
  def initialize(uncompressed_body); end

  def each(&block); end
  def size; end

  private

  def compress_all!; end
  def compressed_each; end
end

class HTTP::Features::AutoDeflate::DeflatedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  def compress; end
end

class HTTP::Features::AutoDeflate::GzippedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  def compress(&block); end
end

class HTTP::Features::AutoDeflate::GzippedBody::BlockIO
  def initialize(block); end

  def write(data); end
end

class HTTP::Features::AutoInflate < ::HTTP::Feature
  def stream_for(connection); end
  def wrap_response(response); end

  private

  def supported_encoding?(response); end
end

HTTP::Features::AutoInflate::SUPPORTED_ENCODING = T.let(T.unsafe(nil), Set)

class HTTP::Features::Instrumentation < ::HTTP::Feature
  def initialize(instrumenter: T.unsafe(nil), namespace: T.unsafe(nil)); end

  def instrumenter; end
  def name; end
  def wrap_request(request); end
  def wrap_response(response); end
end

class HTTP::Features::Instrumentation::NullInstrumenter
  def finish(_name, _payload); end
  def instrument(name, payload = T.unsafe(nil)); end
  def start(_name, _payload); end
end

class HTTP::Features::Logging < ::HTTP::Feature
  def initialize(logger: T.unsafe(nil)); end

  def logger; end
  def wrap_request(request); end
  def wrap_response(response); end
end

class HTTP::Features::Logging::NullLogger
  def debug(*_args); end
  def debug?; end
  def error(*_args); end
  def error?; end
  def fatal(*_args); end
  def fatal?; end
  def info(*_args); end
  def info?; end
  def warn(*_args); end
  def warn?; end
end

class HTTP::Features::NormalizeUri < ::HTTP::Feature
  def initialize(normalizer: T.unsafe(nil)); end

  def normalizer; end
end

class HTTP::HeaderError < ::HTTP::Error; end

class HTTP::Headers
  include ::Enumerable
  extend ::Forwardable

  def initialize; end

  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def add(name, value); end
  def delete(name); end
  def each; end
  def empty?(*args, &block); end
  def get(name); end
  def hash(*args, &block); end
  def include?(name); end
  def inspect; end
  def keys; end
  def merge(other); end
  def merge!(other); end
  def set(name, value); end
  def to_a; end
  def to_h; end
  def to_hash; end

  private

  def initialize_copy(orig); end
  def normalize_header(name); end

  class << self
    def [](object); end
    def coerce(object); end
  end
end

HTTP::Headers::ACCEPT = T.let(T.unsafe(nil), String)
HTTP::Headers::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)
HTTP::Headers::AGE = T.let(T.unsafe(nil), String)
HTTP::Headers::AUTHORIZATION = T.let(T.unsafe(nil), String)
HTTP::Headers::CACHE_CONTROL = T.let(T.unsafe(nil), String)
HTTP::Headers::CANONICAL_NAME_RE = T.let(T.unsafe(nil), Regexp)
HTTP::Headers::COMPLIANT_NAME_RE = T.let(T.unsafe(nil), Regexp)
HTTP::Headers::CONNECTION = T.let(T.unsafe(nil), String)
HTTP::Headers::CONTENT_ENCODING = T.let(T.unsafe(nil), String)
HTTP::Headers::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
HTTP::Headers::CONTENT_TYPE = T.let(T.unsafe(nil), String)
HTTP::Headers::COOKIE = T.let(T.unsafe(nil), String)
HTTP::Headers::DATE = T.let(T.unsafe(nil), String)
HTTP::Headers::ETAG = T.let(T.unsafe(nil), String)
HTTP::Headers::EXPIRES = T.let(T.unsafe(nil), String)
HTTP::Headers::HOST = T.let(T.unsafe(nil), String)
HTTP::Headers::IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)
HTTP::Headers::IF_NONE_MATCH = T.let(T.unsafe(nil), String)
HTTP::Headers::LAST_MODIFIED = T.let(T.unsafe(nil), String)
HTTP::Headers::LOCATION = T.let(T.unsafe(nil), String)

module HTTP::Headers::Mixin
  extend ::Forwardable

  def [](*args, &block); end
  def []=(*args, &block); end
  def headers; end
end

HTTP::Headers::PROXY_AUTHORIZATION = T.let(T.unsafe(nil), String)
HTTP::Headers::SET_COOKIE = T.let(T.unsafe(nil), String)
HTTP::Headers::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
HTTP::Headers::USER_AGENT = T.let(T.unsafe(nil), String)
HTTP::Headers::VARY = T.let(T.unsafe(nil), String)
HTTP::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

module HTTP::MimeType
  class << self
    def [](type); end
    def normalize(type); end
    def register_adapter(type, adapter); end
    def register_alias(type, shortcut); end

    private

    def adapters; end
    def aliases; end
  end
end

class HTTP::MimeType::Adapter
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def decode(*_arg0); end
  def encode(*_arg0); end

  class << self
    def decode(*args, &block); end
    def encode(*args, &block); end
  end
end

class HTTP::MimeType::JSON < ::HTTP::MimeType::Adapter
  def decode(str); end
  def encode(obj); end
end

class HTTP::Options
  def initialize(options = T.unsafe(nil)); end

  def body; end
  def cookies; end
  def dup; end
  def encoding; end
  def feature(name); end
  def features; end
  def features=(features); end
  def follow; end
  def follow=(value); end
  def form; end
  def headers; end
  def json; end
  def keep_alive_timeout; end
  def merge(other); end
  def nodelay; end
  def params; end
  def persistent; end
  def persistent=(value); end
  def persistent?; end
  def proxy; end
  def response; end
  def socket_class; end
  def ssl; end
  def ssl_context; end
  def ssl_socket_class; end
  def timeout_class; end
  def timeout_options; end
  def to_hash; end
  def with_body(value); end
  def with_cookies(value); end
  def with_encoding(value); end
  def with_features(value); end
  def with_follow(value); end
  def with_form(value); end
  def with_headers(value); end
  def with_json(value); end
  def with_keep_alive_timeout(value); end
  def with_nodelay(value); end
  def with_params(value); end
  def with_persistent(value); end
  def with_proxy(value); end
  def with_response(value); end
  def with_socket_class(value); end
  def with_ssl(value); end
  def with_ssl_context(value); end
  def with_ssl_socket_class(value); end
  def with_timeout_class(value); end
  def with_timeout_options(value); end

  protected

  def []=(option, val); end
  def body=(_arg0); end
  def cookies=(_arg0); end
  def encoding=(_arg0); end
  def form=(_arg0); end
  def headers=(_arg0); end
  def json=(_arg0); end
  def keep_alive_timeout=(_arg0); end
  def nodelay=(_arg0); end
  def params=(_arg0); end
  def proxy=(_arg0); end
  def response=(_arg0); end
  def socket_class=(_arg0); end
  def ssl=(_arg0); end
  def ssl_context=(_arg0); end
  def ssl_socket_class=(_arg0); end
  def timeout_class=(_arg0); end
  def timeout_options=(_arg0); end

  private

  def argument_error!(message); end

  class << self
    def available_features; end
    def default_socket_class; end
    def default_socket_class=(_arg0); end
    def default_ssl_socket_class; end
    def default_ssl_socket_class=(_arg0); end
    def default_timeout_class; end
    def default_timeout_class=(_arg0); end
    def defined_options; end
    def new(options = T.unsafe(nil)); end
    def register_feature(name, impl); end

    protected

    def def_option(name, reader_only: T.unsafe(nil), &interpreter); end
  end
end

class HTTP::Redirector
  def initialize(opts = T.unsafe(nil)); end

  def max_hops; end
  def perform(request, response); end
  def strict; end

  private

  def endless_loop?; end
  def redirect_to(uri); end
  def too_many_hops?; end
end

class HTTP::Redirector::EndlessRedirectError < ::HTTP::Redirector::TooManyRedirectsError; end
HTTP::Redirector::REDIRECT_CODES = T.let(T.unsafe(nil), Set)
HTTP::Redirector::SEE_OTHER_ALLOWED_VERBS = T.let(T.unsafe(nil), Set)
HTTP::Redirector::STRICT_SENSITIVE_CODES = T.let(T.unsafe(nil), Set)
class HTTP::Redirector::TooManyRedirectsError < ::HTTP::ResponseError; end
HTTP::Redirector::UNSAFE_VERBS = T.let(T.unsafe(nil), Set)

class HTTP::Request
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  def initialize(opts); end

  def body; end
  def connect_using_proxy(socket); end
  def headline; end
  def host(*args, &block); end
  def include_proxy_authorization_header; end
  def include_proxy_headers; end
  def inspect; end
  def proxy; end
  def proxy_authorization_header; end
  def proxy_connect_header; end
  def proxy_connect_headers; end
  def redirect(uri, verb = T.unsafe(nil)); end
  def scheme; end
  def socket_host; end
  def socket_port; end
  def stream(socket); end
  def uri; end
  def uri_normalizer; end
  def using_authenticated_proxy?; end
  def using_proxy?; end
  def verb; end
  def version; end

  private

  def default_host_header_value; end
  def port; end
  def prepare_body(body); end
  def prepare_headers(headers); end
end

class HTTP::Request::Body
  def initialize(source); end

  def ==(other); end
  def each(&block); end
  def size; end
  def source; end

  private

  def rewind(io); end
  def validate_source_type!; end
end

class HTTP::Request::Body::ProcIO
  def initialize(block); end

  def write(data); end
end

HTTP::Request::METHODS = T.let(T.unsafe(nil), Array)
HTTP::Request::PORTS = T.let(T.unsafe(nil), Hash)
HTTP::Request::SCHEMES = T.let(T.unsafe(nil), Array)
HTTP::Request::USER_AGENT = T.let(T.unsafe(nil), String)
class HTTP::Request::UnsupportedMethodError < ::HTTP::RequestError; end
class HTTP::Request::UnsupportedSchemeError < ::HTTP::RequestError; end

class HTTP::Request::Writer
  def initialize(socket, body, headers, headline); end

  def add_body_type_headers; end
  def add_headers; end
  def chunked?; end
  def connect_through_proxy; end
  def each_chunk; end
  def encode_chunk(chunk); end
  def join_headers; end
  def send_request; end
  def stream; end

  private

  def write(data); end
end

HTTP::Request::Writer::CHUNKED = T.let(T.unsafe(nil), String)
HTTP::Request::Writer::CHUNKED_END = T.let(T.unsafe(nil), String)
HTTP::Request::Writer::CRLF = T.let(T.unsafe(nil), String)
HTTP::Request::Writer::ZERO = T.let(T.unsafe(nil), String)
class HTTP::RequestError < ::HTTP::Error; end

class HTTP::Response
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  def initialize(opts); end

  def body; end
  def charset(*args, &block); end
  def chunked?; end
  def code(*args, &block); end
  def connection(*args, &block); end
  def content_length; end
  def content_type; end
  def cookies; end
  def flush; end
  def inspect; end
  def mime_type(*args, &block); end
  def parse(as = T.unsafe(nil)); end
  def proxy_headers; end
  def readpartial(*args, &block); end
  def reason(*args, &block); end
  def status; end
  def to_a; end
  def to_s(*args, &block); end
  def to_str(*args, &block); end
  def uri; end
  def version; end
end

class HTTP::Response::Body
  include ::Enumerable
  extend ::Forwardable

  def initialize(stream, encoding: T.unsafe(nil)); end

  def connection; end
  def each; end
  def empty?(*args, &block); end
  def inspect; end
  def readpartial(*args); end
  def stream!; end
  def to_s; end
  def to_str; end

  private

  def find_encoding(encoding); end
end

class HTTP::Response::Inflater
  def initialize(connection); end

  def connection; end
  def readpartial(*args); end

  private

  def zstream; end
end

class HTTP::Response::Parser
  def initialize; end

  def <<(data); end
  def add(data); end
  def finished?; end
  def headers; end
  def headers?; end
  def http_version; end
  def on_body(_response, chunk); end
  def on_header_field(_response, field); end
  def on_header_value(_response, value); end
  def on_headers_complete(_reposse); end
  def on_message_complete(_response); end
  def read(size); end
  def reset; end
  def status_code; end

  private

  def append_header; end
end

class HTTP::Response::Status
  def __getobj__; end
  def __setobj__(obj); end
  def accepted?; end
  def already_reported?; end
  def bad_gateway?; end
  def bad_request?; end
  def client_error?; end
  def code; end
  def conflict?; end
  def continue?; end
  def created?; end
  def expectation_failed?; end
  def failed_dependency?; end
  def forbidden?; end
  def found?; end
  def gateway_timeout?; end
  def gone?; end
  def http_version_not_supported?; end
  def im_used?; end
  def informational?; end
  def inspect; end
  def insufficient_storage?; end
  def internal_server_error?; end
  def length_required?; end
  def locked?; end
  def loop_detected?; end
  def method_not_allowed?; end
  def misdirected_request?; end
  def moved_permanently?; end
  def multi_status?; end
  def multiple_choices?; end
  def network_authentication_required?; end
  def no_content?; end
  def non_authoritative_information?; end
  def not_acceptable?; end
  def not_extended?; end
  def not_found?; end
  def not_implemented?; end
  def not_modified?; end
  def ok?; end
  def partial_content?; end
  def payload_too_large?; end
  def payment_required?; end
  def permanent_redirect?; end
  def precondition_failed?; end
  def precondition_required?; end
  def processing?; end
  def proxy_authentication_required?; end
  def range_not_satisfiable?; end
  def reason; end
  def redirect?; end
  def request_header_fields_too_large?; end
  def request_timeout?; end
  def reset_content?; end
  def see_other?; end
  def server_error?; end
  def service_unavailable?; end
  def success?; end
  def switching_protocols?; end
  def temporary_redirect?; end
  def to_s; end
  def to_sym; end
  def too_many_requests?; end
  def unauthorized?; end
  def unavailable_for_legal_reasons?; end
  def unprocessable_entity?; end
  def unsupported_media_type?; end
  def upgrade_required?; end
  def uri_too_long?; end
  def use_proxy?; end
  def variant_also_negotiates?; end

  class << self
    def [](object); end
    def coerce(object); end

    private

    def symbolize(str); end
  end
end

HTTP::Response::Status::REASONS = T.let(T.unsafe(nil), Hash)
HTTP::Response::Status::SYMBOLS = T.let(T.unsafe(nil), Hash)
HTTP::Response::Status::SYMBOL_CODES = T.let(T.unsafe(nil), Hash)
class HTTP::ResponseError < ::HTTP::Error; end
class HTTP::StateError < ::HTTP::ResponseError; end
module HTTP::Timeout; end

class HTTP::Timeout::Global < ::HTTP::Timeout::Null
  def initialize(*args); end

  def <<(data); end
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end
  def connect_ssl; end
  def readpartial(size, buffer = T.unsafe(nil)); end
  def reset_counter; end
  def write(data); end

  private

  def log_time; end
  def perform_io; end
  def read_nonblock(size, buffer = T.unsafe(nil)); end
  def reset_timer; end
  def wait_readable_or_timeout; end
  def wait_writable_or_timeout; end
  def write_nonblock(data); end
end

class HTTP::Timeout::Null
  extend ::Forwardable

  def initialize(options = T.unsafe(nil)); end

  def <<(data); end
  def close(*args, &block); end
  def closed?(*args, &block); end
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end
  def connect_ssl; end
  def options; end
  def readpartial(size, buffer = T.unsafe(nil)); end
  def socket; end
  def start_tls(host, ssl_socket_class, ssl_context); end
  def write(data); end

  private

  def rescue_readable(timeout = T.unsafe(nil)); end
  def rescue_writable(timeout = T.unsafe(nil)); end
end

class HTTP::Timeout::PerOperation < ::HTTP::Timeout::Null
  def initialize(*args); end

  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end
  def connect_ssl; end
  def readpartial(size, buffer = T.unsafe(nil)); end
  def write(data); end
end

HTTP::Timeout::PerOperation::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Float)
HTTP::Timeout::PerOperation::READ_TIMEOUT = T.let(T.unsafe(nil), Float)
HTTP::Timeout::PerOperation::WRITE_TIMEOUT = T.let(T.unsafe(nil), Float)
class HTTP::TimeoutError < ::HTTP::Error; end

class HTTP::URI
  extend ::Forwardable

  def initialize(options_or_uri = T.unsafe(nil)); end

  def ==(other); end
  def authority(*args, &block); end
  def authority=(*args, &block); end
  def dup; end
  def eql?(other); end
  def fragment(*args, &block); end
  def fragment=(*args, &block); end
  def hash; end
  def host(*args, &block); end
  def host=(*args, &block); end
  def http?; end
  def https?; end
  def inspect; end
  def join(*args, &block); end
  def normalize(*args, &block); end
  def normalized_authority(*args, &block); end
  def normalized_fragment(*args, &block); end
  def normalized_host(*args, &block); end
  def normalized_password(*args, &block); end
  def normalized_path(*args, &block); end
  def normalized_port(*args, &block); end
  def normalized_query(*args, &block); end
  def normalized_scheme(*args, &block); end
  def normalized_user(*args, &block); end
  def omit(*args, &block); end
  def origin(*args, &block); end
  def origin=(*args, &block); end
  def password(*args, &block); end
  def password=(*args, &block); end
  def path(*args, &block); end
  def path=(*args, &block); end
  def port; end
  def port=(*args, &block); end
  def query(*args, &block); end
  def query=(*args, &block); end
  def query_values(*args, &block); end
  def query_values=(*args, &block); end
  def request_uri(*args, &block); end
  def request_uri=(*args, &block); end
  def scheme(*args, &block); end
  def scheme=(*args, &block); end
  def to_s; end
  def to_str; end
  def user(*args, &block); end
  def user=(*args, &block); end

  class << self
    def form_encode(form_values, sort = T.unsafe(nil)); end
    def parse(uri); end
  end
end

HTTP::URI::HTTPS_SCHEME = T.let(T.unsafe(nil), String)
HTTP::URI::HTTP_SCHEME = T.let(T.unsafe(nil), String)
HTTP::URI::NORMALIZER = T.let(T.unsafe(nil), Proc)
HTTP::VERSION = T.let(T.unsafe(nil), String)
