# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kubeclient` gem.
# Please instead update this file by running `bin/tapioca gem kubeclient`.

class KubeException < ::StandardError
  def initialize(error_code, message, response); end

  def error_code; end
  def message; end
  def response; end
  def to_s; end
end

module Kubeclient; end

class Kubeclient::AmazonEksCredentials
  class << self
    def token(credentials, eks_cluster); end
  end
end

class Kubeclient::AmazonEksCredentials::AmazonEksDependencyError < ::LoadError; end

class Kubeclient::Client
  include ::Kubeclient::ClientMixin

  def initialize(uri, version = T.unsafe(nil), **options); end
end

module Kubeclient::ClientMixin
  def all_entities(options = T.unsafe(nil)); end
  def api; end
  def api_endpoint; end
  def api_valid?; end
  def apply_entity(resource_name, resource, field_manager:, force: T.unsafe(nil)); end
  def auth_options; end
  def build_namespace_prefix(namespace); end
  def create_entity(entity_type, resource_name, entity_config); end
  def create_rest_client(path = T.unsafe(nil)); end
  def define_entity_methods; end
  def delete_entity(resource_name, name, namespace = T.unsafe(nil), delete_options: T.unsafe(nil)); end
  def discover; end
  def discovered; end
  def discovery_needed?(method_sym); end
  def get_entities(entity_type, resource_name, options = T.unsafe(nil)); end
  def get_entity(resource_name, name, namespace = T.unsafe(nil), options = T.unsafe(nil)); end
  def get_pod_log(pod_name, namespace, container: T.unsafe(nil), previous: T.unsafe(nil), timestamps: T.unsafe(nil), since_time: T.unsafe(nil), tail_lines: T.unsafe(nil), limit_bytes: T.unsafe(nil)); end
  def handle_exception; end
  def handle_uri(uri, path); end
  def headers; end
  def http_max_redirects; end
  def http_proxy_uri; end
  def initialize_client(uri, path, version, ssl_options: T.unsafe(nil), auth_options: T.unsafe(nil), socket_options: T.unsafe(nil), timeouts: T.unsafe(nil), http_proxy_uri: T.unsafe(nil), http_max_redirects: T.unsafe(nil), as: T.unsafe(nil)); end
  def method_missing(method_sym, *args, &block); end
  def patch_entity(resource_name, name, patch, strategy, namespace); end
  def process_template(template); end
  def proxy_url(kind, name, port, namespace = T.unsafe(nil)); end
  def rest_client; end
  def ssl_options; end
  def update_entity(resource_name, entity_config); end
  def watch_entities(resource_name, options = T.unsafe(nil), &block); end
  def watch_pod_log(pod_name, namespace, container: T.unsafe(nil), &block); end

  private

  def bearer_token(bearer_token); end
  def fetch_entities; end
  def format_datetime(value); end
  def format_response(as, body, list_type = T.unsafe(nil)); end
  def http_options(uri); end
  def load_entities; end
  def respond_to_missing?(method_sym, include_private = T.unsafe(nil)); end
  def return_or_yield_to_watcher(watcher, &block); end
  def validate_auth_options(opts); end
  def validate_bearer_token_file; end

  class << self
    def parse_definition(kind, name); end
    def resolve_unconventional_method_names(name, kind, singular_name); end
    def underscore_entity(entity_name); end
  end
end

Kubeclient::ClientMixin::DEFAULT_AUTH_OPTIONS = T.let(T.unsafe(nil), Hash)
Kubeclient::ClientMixin::DEFAULT_HTTP_MAX_REDIRECTS = T.let(T.unsafe(nil), Integer)
Kubeclient::ClientMixin::DEFAULT_SOCKET_OPTIONS = T.let(T.unsafe(nil), Hash)
Kubeclient::ClientMixin::DEFAULT_SSL_OPTIONS = T.let(T.unsafe(nil), Hash)
Kubeclient::ClientMixin::DEFAULT_TIMEOUTS = T.let(T.unsafe(nil), Hash)
Kubeclient::ClientMixin::ENTITY_METHODS = T.let(T.unsafe(nil), Array)
Kubeclient::ClientMixin::IRREGULAR_NAMES = T.let(T.unsafe(nil), Hash)
Kubeclient::ClientMixin::SEARCH_ARGUMENTS = T.let(T.unsafe(nil), Hash)
Kubeclient::ClientMixin::WATCH_ARGUMENTS = T.let(T.unsafe(nil), Hash)
module Kubeclient::Common; end

class Kubeclient::Common::EntityList
  def initialize(kind, resource_version, list, continue = T.unsafe(nil)); end

  def continue; end
  def kind; end
  def last?; end
  def resourceVersion; end
end

class Kubeclient::Common::MissingKindCompatibility
  class << self
    def resource_kind(name); end
  end
end

Kubeclient::Common::MissingKindCompatibility::MAPPING = T.let(T.unsafe(nil), Hash)

class Kubeclient::Common::WatchStream
  def initialize(uri, http_options, formatter:); end

  def each; end
  def finish; end

  private

  def build_client; end
  def build_client_options; end
  def follow_option; end
  def max_hops; end
  def using_proxy; end
end

class Kubeclient::Config
  def initialize(data, kcfg_path); end

  def context(context_name = T.unsafe(nil)); end
  def contexts; end

  private

  def allow_external_lookups?; end
  def cluster_ca_data?(cluster); end
  def expand_command_option(config, key); end
  def ext_command_path(path); end
  def ext_file_path(path); end
  def fetch_context(context_name); end
  def fetch_token_from_provider(auth_provider); end
  def fetch_user_auth_options(user); end
  def fetch_user_cert_data(user); end
  def fetch_user_key_data(user); end
  def populate_cert_store_from_cluster_ca_data(cluster, cert_store); end

  class << self
    def read(filename); end
  end
end

class Kubeclient::Config::Context
  def initialize(api_endpoint, api_version, ssl_options, auth_options, namespace); end

  def api_endpoint; end
  def api_version; end
  def auth_options; end
  def namespace; end
  def ssl_options; end
end

class Kubeclient::ExecCredentials
  class << self
    def run(opts); end

    private

    def map_env(env); end
    def validate_client_credentials_status(status); end
    def validate_credentials(opts, creds); end
    def validate_credentials_status(status); end
    def validate_opts(opts); end
  end
end

class Kubeclient::GCPAuthProvider
  class << self
    def token(config); end
  end
end

class Kubeclient::GCPCommandCredentials
  class << self
    def token(config); end

    private

    def extract_token(output, token_key); end
  end
end

class Kubeclient::GoogleApplicationDefaultCredentials
  class << self
    def token; end
  end
end

class Kubeclient::GoogleApplicationDefaultCredentials::GoogleDependencyError < ::LoadError; end
class Kubeclient::HttpError < ::KubeException; end

class Kubeclient::OIDCAuthProvider
  class << self
    def expired?(id_token, discovery); end
    def token(provider_config); end
  end
end

class Kubeclient::OIDCAuthProvider::OpenIDConnectDependencyError < ::LoadError; end

class Kubeclient::Resource < ::RecursiveOpenStruct
  def initialize(hash = T.unsafe(nil), args = T.unsafe(nil)); end
end

class Kubeclient::ResourceNotFoundError < ::Kubeclient::HttpError; end
Kubeclient::VERSION = T.let(T.unsafe(nil), String)
