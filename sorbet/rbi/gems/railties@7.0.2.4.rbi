# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `railties` gem.
# Please instead update this file by running `bin/tapioca gem railties`.

module Rails; end

module Rails::Command
  include ::Rails::Command::Behavior
  extend ::ActiveSupport::Autoload
  extend ::Rails::Command::Behavior::ClassMethods

  class << self
    def environment; end
    def find_by_namespace(namespace, command_name = T.unsafe(nil)); end
    def hidden_commands; end
    def invoke(full_namespace, args = T.unsafe(nil), **config); end
    def print_commands; end
    def root; end

    private

    def command_type; end
    def commands; end
    def file_lookup_paths; end
    def lookup_paths; end
    def rails_new_with_no_path?(args); end
  end
end

module Rails::Command::Actions
  def load_generators; end
  def load_tasks; end
  def require_application!; end
  def require_application_and_environment!; end
  def require_environment!; end
  def set_application_directory!; end
end

class Rails::Command::Base < ::Thor
  include ::Rails::Command::Actions

  def help; end

  class << self
    def banner(*_arg0); end
    def base_name; end
    def command_name; end
    def default_command_root; end
    def desc(usage = T.unsafe(nil), description = T.unsafe(nil), options = T.unsafe(nil)); end
    def engine?; end
    def executable; end
    def exit_on_failure?; end
    def hide_command!; end
    def inherited(base); end
    def namespace(name = T.unsafe(nil)); end
    def perform(command, args, config); end
    def printing_commands; end
    def usage_path; end

    private

    def command_root_namespace; end
    def create_command(meth); end
    def namespaced_commands; end
    def relative_command_path; end
  end
end

class Rails::Command::Base::CorrectableError < ::Rails::Command::Base::Error
  include ::DidYouMean::Correctable

  def initialize(message, key, options); end

  def corrections; end
  def key; end
  def options; end
end

class Rails::Command::Base::Error < ::Thor::Error; end

module Rails::Command::Behavior
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Rails::Command::Behavior::ClassMethods
end

module Rails::Command::Behavior::ClassMethods
  def no_color!; end
  def subclasses; end

  private

  def lookup(namespaces); end
  def lookup!; end
  def namespaces_to_paths(namespaces); end
  def print_list(base, namespaces); end
end

class Rails::Command::DbconsoleCommand < ::Rails::Command::Base
  include ::Rails::Command::EnvironmentArgument

  def dbconsole; end
  def environment_desc; end
  def environment_desc=(_arg0); end
  def environment_desc?; end
  def perform; end

  class << self
    def environment_desc; end
    def environment_desc=(value); end
    def environment_desc?; end
  end
end

module Rails::Command::EnvironmentArgument
  extend ::ActiveSupport::Concern

  private

  def acceptable_environment(env = T.unsafe(nil)); end
  def available_environments; end
  def extract_environment_option_from_argument(default_environment: T.unsafe(nil)); end
end

Rails::Command::HELP_MAPPINGS = T.let(T.unsafe(nil), Array)
module Rails::Configuration; end

class Rails::Configuration::Generators
  def initialize; end

  def after_generate(&block); end
  def after_generate_callbacks; end
  def aliases; end
  def aliases=(_arg0); end
  def api_only; end
  def api_only=(_arg0); end
  def colorize_logging; end
  def colorize_logging=(_arg0); end
  def fallbacks; end
  def fallbacks=(_arg0); end
  def hidden_namespaces; end
  def hide_namespace(namespace); end
  def method_missing(method, *args); end
  def options; end
  def options=(_arg0); end
  def templates; end
  def templates=(_arg0); end

  private

  def initialize_copy(source); end
end

class Rails::Configuration::MiddlewareStackProxy
  def initialize(operations = T.unsafe(nil), delete_operations = T.unsafe(nil)); end

  def +(other); end
  def delete(*_arg0, &_arg1); end
  def insert(*_arg0, &_arg1); end
  def insert_after(*_arg0, &_arg1); end
  def insert_before(*_arg0, &_arg1); end
  def merge_into(other); end
  def move(*_arg0, &_arg1); end
  def move_after(*_arg0, &_arg1); end
  def move_before(*_arg0, &_arg1); end
  def swap(*_arg0, &_arg1); end
  def unshift(*_arg0, &_arg1); end
  def use(*_arg0, &_arg1); end

  protected

  def delete_operations; end
  def operations; end
end

class Rails::DBConsole
  def initialize(options = T.unsafe(nil)); end

  def database; end
  def db_config; end
  def environment; end
  def start; end

  private

  def configurations; end
  def find_cmd_and_exec(commands, *args); end

  class << self
    def start(*args); end
  end
end

module Rails::Generators
  include ::Rails::Command::Behavior
  extend ::Rails::Command::Behavior::ClassMethods

  def namespace; end
  def namespace=(val); end

  class << self
    def add_generated_file(file); end
    def after_generate_callbacks; end
    def aliases; end
    def api_only!; end
    def configure!(config); end
    def fallbacks; end
    def find_by_namespace(name, base = T.unsafe(nil), context = T.unsafe(nil)); end
    def help(command = T.unsafe(nil)); end
    def hidden_namespaces; end
    def hide_namespace(*namespaces); end
    def hide_namespaces(*namespaces); end
    def invoke(namespace, args = T.unsafe(nil), config = T.unsafe(nil)); end
    def namespace; end
    def namespace=(val); end
    def options; end
    def print_generators; end
    def public_namespaces; end
    def sorted_groups; end
    def templates_path; end

    private

    def command_type; end
    def file_lookup_paths; end
    def invoke_fallbacks_for(name, base); end
    def lookup_paths; end
    def print_list(base, namespaces); end
    def run_after_generate_callback; end
  end
end

module Rails::Generators::Actions
  def initialize(*_arg0); end

  def add_source(source, options = T.unsafe(nil), &block); end
  def application(data = T.unsafe(nil), options = T.unsafe(nil)); end
  def environment(data = T.unsafe(nil), options = T.unsafe(nil)); end
  def gem(*args); end
  def gem_group(*names, &block); end
  def generate(what, *args); end
  def git(commands = T.unsafe(nil)); end
  def github(repo, options = T.unsafe(nil), &block); end
  def initializer(filename, data = T.unsafe(nil)); end
  def lib(filename, data = T.unsafe(nil)); end
  def rails_command(command, options = T.unsafe(nil)); end
  def rake(command, options = T.unsafe(nil)); end
  def rakefile(filename, data = T.unsafe(nil)); end
  def readme(path); end
  def route(routing_code, namespace: T.unsafe(nil)); end
  def vendor(filename, data = T.unsafe(nil)); end

  private

  def append_file_with_newline(path, str, options = T.unsafe(nil)); end
  def execute_command(executor, command, options = T.unsafe(nil)); end
  def extify(name); end
  def indentation; end
  def log(*args); end
  def match_file(path, pattern); end
  def optimize_indentation(value, amount = T.unsafe(nil)); end
  def quote(value); end
  def rebase_indentation(value, amount = T.unsafe(nil)); end
  def route_namespace_pattern(namespace); end
  def with_indentation(&block); end
end

class Rails::Generators::Actions::CreateMigration < ::Thor::Actions::CreateFile
  def existing_migration; end
  def exists?; end
  def identical?; end
  def invoke!; end
  def migration_dir; end
  def migration_file_name; end
  def relative_existing_migration; end
  def revoke!; end

  private

  def on_conflict_behavior; end
  def say_status(status, color, message = T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def initialize(name); end

  def destroy; end
  def errors; end
  def name; end
  def save; end
  def update(params = T.unsafe(nil)); end

  class << self
    def all(klass); end
    def build(klass, params = T.unsafe(nil)); end
    def find(klass, params = T.unsafe(nil)); end
  end
end

module Rails::Generators::AppName
  private

  def app_const; end
  def app_const_base; end
  def app_name; end
  def camelized; end
  def defined_app_const_base; end
  def defined_app_const_base?; end
  def defined_app_name; end
  def original_app_name; end
  def valid_const?; end
end

Rails::Generators::AppName::RESERVED_NAMES = T.let(T.unsafe(nil), Array)

class Rails::Generators::Base < ::Thor::Group
  include ::Thor::Actions
  include ::Rails::Generators::Actions
  extend ::Thor::Actions::ClassMethods

  private

  def class_collisions(*class_names); end
  def extract_last_module(nesting); end
  def indent(content, multiplier = T.unsafe(nil)); end
  def module_namespacing(&block); end
  def namespace; end
  def namespace_dirs; end
  def namespaced?; end
  def namespaced_path; end
  def wrap_with_namespace(content); end

  class << self
    def add_shebang_option!; end
    def banner; end
    def base_name; end
    def base_root; end
    def class_option(name, options = T.unsafe(nil)); end
    def default_aliases_for_option(name, options); end
    def default_for_option(config, name, options, default); end
    def default_generator_root; end
    def default_source_root; end
    def default_value_for_option(name, options); end
    def desc(description = T.unsafe(nil)); end
    def exit_on_failure?; end
    def generator_name; end
    def hide!; end
    def hook_for(*names, &block); end
    def hooks; end
    def inherited(base); end
    def namespace(name = T.unsafe(nil)); end
    def prepare_for_invocation(name, value); end
    def remove_hook_for(*names); end
    def source_root(path = T.unsafe(nil)); end
    def usage_path; end
  end
end

Rails::Generators::DEFAULT_ALIASES = T.let(T.unsafe(nil), Hash)
Rails::Generators::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module Rails::Generators::Database
  def initialize(*_arg0); end

  def convert_database_option_for_jruby; end
  def gem_for_database(database = T.unsafe(nil)); end

  private

  def mysql_socket; end
end

Rails::Generators::Database::DATABASES = T.let(T.unsafe(nil), Array)
Rails::Generators::Database::JDBC_DATABASES = T.let(T.unsafe(nil), Array)
class Rails::Generators::Error < ::Thor::Error; end

class Rails::Generators::GeneratedAttribute
  def initialize(name, type = T.unsafe(nil), index_type = T.unsafe(nil), attr_options = T.unsafe(nil)); end

  def attachment?; end
  def attachments?; end
  def attr_options; end
  def column_name; end
  def default; end
  def field_type; end
  def foreign_key?; end
  def has_index?; end
  def has_uniq_index?; end
  def human_name; end
  def index_name; end
  def index_name=(_arg0); end
  def inject_index_options; end
  def inject_options; end
  def name; end
  def name=(_arg0); end
  def options_for_migration; end
  def password_digest?; end
  def plural_name; end
  def polymorphic?; end
  def reference?; end
  def required?; end
  def rich_text?; end
  def singular_name; end
  def token?; end
  def type; end
  def type=(_arg0); end
  def virtual?; end

  class << self
    def parse(column_definition); end
    def reference?(type); end
    def valid_index_type?(index_type); end
    def valid_type?(type); end

    private

    def parse_type_and_options(type); end
  end
end

Rails::Generators::GeneratedAttribute::DEFAULT_TYPES = T.let(T.unsafe(nil), Array)
Rails::Generators::GeneratedAttribute::INDEX_OPTIONS = T.let(T.unsafe(nil), Array)
Rails::Generators::GeneratedAttribute::UNIQ_INDEX_OPTIONS = T.let(T.unsafe(nil), Array)

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Rails::Generators::Migration::ClassMethods

  def create_migration(destination, data, config = T.unsafe(nil), &block); end
  def migration_class_name; end
  def migration_file_name; end
  def migration_number; end
  def migration_template(source, destination, config = T.unsafe(nil)); end
  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end
  def migration_exists?(dirname, file_name); end
  def migration_lookup_at(dirname); end
  def next_migration_number(dirname); end
end

module Rails::Generators::ModelHelpers
  def initialize(args, *_options); end

  def skip_warn; end
  def skip_warn=(val); end

  private

  def inflection_impossible?(name); end
  def irregular_model_name?(name); end
  def plural_model_name?(name); end

  class << self
    def included(base); end
    def skip_warn; end
    def skip_warn=(val); end
  end
end

Rails::Generators::ModelHelpers::INFLECTION_IMPOSSIBLE_ERROR_MESSAGE = T.let(T.unsafe(nil), String)
Rails::Generators::ModelHelpers::IRREGULAR_MODEL_NAME_WARN_MESSAGE = T.let(T.unsafe(nil), String)
Rails::Generators::ModelHelpers::PLURAL_MODEL_NAME_WARN_MESSAGE = T.let(T.unsafe(nil), String)

class Rails::Generators::NamedBase < ::Rails::Generators::Base
  def initialize(args, *options); end

  def file_name; end
  def js_template(source, destination); end
  def name; end
  def name=(_arg0); end
  def template(source, *args, &block); end

  private

  def application_name; end
  def assign_names!(name); end
  def attributes_names; end
  def class_name; end
  def class_path; end
  def edit_helper(*_arg0, &_arg1); end
  def file_path; end
  def fixture_file_name; end
  def human_name; end
  def i18n_scope; end
  def index_helper(type: T.unsafe(nil)); end
  def inside_template; end
  def inside_template?; end
  def model_resource_name(base_name = T.unsafe(nil), prefix: T.unsafe(nil)); end
  def mountable_engine?; end
  def namespaced_class_path; end
  def new_helper(type: T.unsafe(nil)); end
  def parse_attributes!; end
  def plural_file_name; end
  def plural_name; end
  def plural_route_name; end
  def plural_table_name; end
  def pluralize_table_names?; end
  def redirect_resource_name; end
  def regular_class_path; end
  def route_url; end
  def show_helper(arg = T.unsafe(nil), type: T.unsafe(nil)); end
  def singular_name; end
  def singular_route_name; end
  def singular_table_name; end
  def table_name; end
  def uncountable?; end
  def url_helper_prefix; end

  class << self
    def check_class_collision(options = T.unsafe(nil)); end
  end
end

module Rails::Generators::ResourceHelpers
  include ::Rails::Generators::ModelHelpers

  def initialize(*args); end

  private

  def assign_controller_names!(name); end
  def controller_class_name; end
  def controller_class_path; end
  def controller_file_name; end
  def controller_file_path; end
  def controller_i18n_scope; end
  def controller_name; end
  def orm_class; end
  def orm_instance(name = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

class Rails::Generators::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::Stream
  include ::Rails::Generators::Testing::Behaviour
  include ::Rails::Generators::Testing::SetupAndTeardown
  include ::Rails::Generators::Testing::Assertions
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::Rails::Generators::Testing::Behaviour::ClassMethods

  def current_path; end
  def current_path=(_arg0); end
  def current_path?; end
  def default_arguments; end
  def default_arguments=(_arg0); end
  def default_arguments?; end
  def destination_root; end
  def destination_root=(_arg0); end
  def destination_root?; end
  def generator_class; end
  def generator_class=(_arg0); end
  def generator_class?; end

  class << self
    def current_path; end
    def current_path=(value); end
    def current_path?; end
    def default_arguments; end
    def default_arguments=(value); end
    def default_arguments?; end
    def destination_root; end
    def destination_root=(value); end
    def destination_root?; end
    def generator_class; end
    def generator_class=(value); end
    def generator_class?; end
  end
end

module Rails::Generators::Testing; end

module Rails::Generators::Testing::Assertions
  def assert_class_method(method, content, &block); end
  def assert_directory(relative, *contents); end
  def assert_field_default_value(attribute_type, value); end
  def assert_field_type(attribute_type, field_type); end
  def assert_file(relative, *contents); end
  def assert_instance_method(method, content); end
  def assert_method(method, content); end
  def assert_migration(relative, *contents, &block); end
  def assert_no_directory(relative); end
  def assert_no_file(relative); end
  def assert_no_migration(relative); end
end

module Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Rails::Generators::Testing::Behaviour::ClassMethods

  def create_generated_attribute(attribute_type, name = T.unsafe(nil), index = T.unsafe(nil)); end
  def generator(args = T.unsafe(nil), options = T.unsafe(nil), config = T.unsafe(nil)); end
  def run_generator(args = T.unsafe(nil), config = T.unsafe(nil)); end

  private

  def destination_root_is_set?; end
  def ensure_current_path; end
  def migration_file_name(relative); end
  def prepare_destination; end

  module GeneratedClassMethods
    def current_path; end
    def current_path=(value); end
    def current_path?; end
    def default_arguments; end
    def default_arguments=(value); end
    def default_arguments?; end
    def destination_root; end
    def destination_root=(value); end
    def destination_root?; end
    def generator_class; end
    def generator_class=(value); end
    def generator_class?; end
  end

  module GeneratedInstanceMethods
    def current_path; end
    def current_path=(value); end
    def current_path?; end
    def default_arguments; end
    def default_arguments=(value); end
    def default_arguments?; end
    def destination_root; end
    def destination_root=(value); end
    def destination_root?; end
    def generator_class; end
    def generator_class=(value); end
    def generator_class?; end
  end
end

module Rails::Generators::Testing::Behaviour::ClassMethods
  def arguments(array); end
  def destination(path); end
  def tests(klass); end
end

module Rails::Generators::Testing::SetupAndTeardown
  def setup; end
  def teardown; end
end

module Rails::Initializable
  mixes_in_class_methods ::Rails::Initializable::ClassMethods

  def initializers; end
  def run_initializers(group = T.unsafe(nil), *args); end

  class << self
    def included(base); end
  end
end

module Rails::Initializable::ClassMethods
  def initializer(name, opts = T.unsafe(nil), &blk); end
  def initializers; end
  def initializers_chain; end
  def initializers_for(binding); end
end

class Rails::Initializable::Collection < ::Array
  include ::TSort

  def +(other); end
  def tsort_each_child(initializer, &block); end
  def tsort_each_node; end
end

class Rails::Initializable::Initializer
  def initialize(name, context, options, &block); end

  def after; end
  def before; end
  def belongs_to?(group); end
  def bind(context); end
  def block; end
  def context_class; end
  def name; end
  def run(*args); end
end

module Rails::Paths; end

class Rails::Paths::Path
  include ::Enumerable

  def initialize(root, current, paths, options = T.unsafe(nil)); end

  def <<(path); end
  def absolute_current; end
  def autoload!; end
  def autoload?; end
  def autoload_once!; end
  def autoload_once?; end
  def children; end
  def concat(paths); end
  def each(&block); end
  def eager_load!; end
  def eager_load?; end
  def existent; end
  def existent_directories; end
  def expanded; end
  def extensions; end
  def first; end
  def glob; end
  def glob=(_arg0); end
  def last; end
  def load_path!; end
  def load_path?; end
  def paths; end
  def push(path); end
  def skip_autoload!; end
  def skip_autoload_once!; end
  def skip_eager_load!; end
  def skip_load_path!; end
  def to_a; end
  def to_ary; end
  def unshift(*paths); end

  private

  def files_in(path); end
end

class Rails::Paths::Root
  def initialize(path); end

  def [](path); end
  def []=(path, value); end
  def add(path, options = T.unsafe(nil)); end
  def all_paths; end
  def autoload_once; end
  def autoload_paths; end
  def eager_load; end
  def keys; end
  def load_paths; end
  def path; end
  def path=(_arg0); end
  def values; end
  def values_at(*list); end

  private

  def filter_by(&block); end
end

module Rails::Rack; end

class Rails::Rack::Logger < ::ActiveSupport::LogSubscriber
  def initialize(app, taggers = T.unsafe(nil)); end

  def call(env); end

  private

  def call_app(request, env); end
  def compute_tags(request); end
  def finish(request); end
  def logger; end
  def started_request_message(request); end
end

class Rails::Railtie
  include ::Rails::Initializable
  extend ::ActiveSupport::DescendantsTracker
  extend ::Rails::Initializable::ClassMethods

  def initialize; end

  def config; end
  def configure(&block); end
  def railtie_name(*_arg0, &_arg1); end
  def railtie_namespace; end

  protected

  def run_console_blocks(app); end
  def run_generators_blocks(app); end
  def run_runner_blocks(app); end
  def run_server_blocks(app); end
  def run_tasks_blocks(app); end

  private

  def each_registered_block(type, &block); end

  class << self
    def <=>(other); end
    def abstract_railtie?; end
    def config(*_arg0, &_arg1); end
    def configure(&block); end
    def console(&blk); end
    def generators(&blk); end
    def inherited(subclass); end
    def instance; end
    def railtie_name(name = T.unsafe(nil)); end
    def rake_tasks(&blk); end
    def runner(&blk); end
    def server(&blk); end
    def subclasses; end

    protected

    def increment_load_index; end
    def load_index; end

    private

    def generate_railtie_name(string); end
    def method_missing(name, *args, &block); end
    def register_block_for(type, &blk); end
    def respond_to_missing?(name, _); end
  end
end

Rails::Railtie::ABSTRACT_RAILTIES = T.let(T.unsafe(nil), Array)

class Rails::Railtie::Configuration
  def initialize; end

  def after_initialize(&block); end
  def app_generators; end
  def app_middleware; end
  def before_configuration(&block); end
  def before_eager_load(&block); end
  def before_initialize(&block); end
  def eager_load_namespaces; end
  def respond_to?(name, include_private = T.unsafe(nil)); end
  def to_prepare(&blk); end
  def to_prepare_blocks; end
  def watchable_dirs; end
  def watchable_files; end

  private

  def method_missing(name, *args, &blk); end

  class << self
    def eager_load_namespaces; end
  end
end
