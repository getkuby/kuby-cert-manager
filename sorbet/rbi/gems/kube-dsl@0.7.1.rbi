# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kube-dsl` gem.
# Please instead update this file by running `bin/tapioca gem kube-dsl`.

# typed: strong
module KubeDSL
  extend ::KubeDSL::Entrypoint
end

class KubeDSL::AllowBlank
  def initialize(value); end

  def value; end
end

class KubeDSL::ArrayFieldRes
  include ::KubeDSL::StringHelpers
  include ::KubeDSL::RbiHelpers

  def initialize(name, required, elem_res); end

  def elem_res; end
  def fields_to_rbi(inflector); end
  def fields_to_ruby(inflector); end
  def name; end
  def required; end
  def required?; end
  def serialize_call(inflector); end
  def validations(inflector); end

  private

  def plural_name(inflector); end
  def ruby_type; end
end

class KubeDSL::Builder
  def initialize(schema_dir:, output_dir:, autoload_prefix:, inflector:, dsl_namespace:, entrypoint_namespace:); end

  def autoload_prefix; end
  def dsl_namespace; end
  def each_autoload_file(&block); end
  def each_resource; end
  def each_resource_file; end
  def entrypoint(&block); end
  def entrypoint_namespace; end
  def inflector; end
  def output_dir; end
  def parse_ref(ref_str); end
  def register_resolver(*prefixes, &resolver); end
  def register_serialize_handler(namespace, version, kind, field, &block); end
  def resolvers; end
  def resource_from_ref(ref); end
  def schema_dir; end
  def serialize_handlers; end

  private

  def add_doc_to_resource(res, doc); end
  def add_prop_to_resource(name, prop, res); end
  def add_props_to_resource(properties, res); end
  def autoload_map; end
  def each_autoload_file_helper(amap, path, &block); end
  def load_resources; end
  def resolve_ref(ref_str); end
  def resource_cache; end
  def start_path; end
end

module KubeDSL::DSL; end
module KubeDSL::DSL::Admissionregistration; end
module KubeDSL::DSL::Admissionregistration::V1; end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhook < ::KubeDSL::DSLObject
  def admission_review_versions(*args); end
  def client_config(*args, &block); end
  def client_config_present?; end
  def failure_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def match_policy(*args); end
  def name(*args); end
  def namespace_selector(*args, &block); end
  def namespace_selector_present?; end
  def object_selector(*args, &block); end
  def object_selector_present?; end
  def reinvocation_policy(*args); end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def side_effects(*args); end
  def timeout_seconds(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfiguration < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def webhook(elem_name = T.unsafe(nil), &block); end
  def webhooks; end
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfigurationList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Admissionregistration::V1::RuleWithOperations < ::KubeDSL::DSLObject
  def api_groups(*args); end
  def api_versions(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def operations(*args); end
  def resources(*args); end
  def scope(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Admissionregistration::V1::ServiceReference < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end
  def path(*args); end
  def port(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhook < ::KubeDSL::DSLObject
  def admission_review_versions(*args); end
  def client_config(*args, &block); end
  def client_config_present?; end
  def failure_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def match_policy(*args); end
  def name(*args); end
  def namespace_selector(*args, &block); end
  def namespace_selector_present?; end
  def object_selector(*args, &block); end
  def object_selector_present?; end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def side_effects(*args); end
  def timeout_seconds(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfiguration < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def webhook(elem_name = T.unsafe(nil), &block); end
  def webhooks; end
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfigurationList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Admissionregistration::V1::WebhookClientConfig < ::KubeDSL::DSLObject
  def ca_bundle(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service(*args, &block); end
  def service_present?; end
  def url(*args); end
end

module KubeDSL::DSL::Apiextensions; end
module KubeDSL::DSL::Apiextensions::V1; end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceColumnDefinition < ::KubeDSL::DSLObject
  def description(*args); end
  def format(*args); end
  def json_path(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def priority(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceConversion < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def strategy(*args); end
  def webhook(*args, &block); end
  def webhook_present?; end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionNames < ::KubeDSL::DSLObject
  def categories(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def list_kind(*args); end
  def plural(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def short_names(*args); end
  def singular(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionSpec < ::KubeDSL::DSLObject
  def conversion(*args, &block); end
  def conversion_present?; end
  def group(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def names(*args, &block); end
  def names_present?; end
  def preserve_unknown_fields(*args); end
  def scope(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def version(elem_name = T.unsafe(nil), &block); end
  def versions; end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionStatus < ::KubeDSL::DSLObject
  def accepted_names(*args, &block); end
  def accepted_names_present?; end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def stored_versions(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionVersion < ::KubeDSL::DSLObject
  def additional_printer_column(elem_name = T.unsafe(nil), &block); end
  def additional_printer_columns; end
  def deprecated(*args); end
  def deprecation_warning(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def schema(*args, &block); end
  def schema_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def served(*args); end
  def storage(*args); end
  def subresources(*args, &block); end
  def subresources_present?; end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresourceScale < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def label_selector_path(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec_replicas_path(*args); end
  def status_replicas_path(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresources < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def scale(*args, &block); end
  def scale_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceValidation < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def open_apiv3_schema(*args, &block); end
  def open_apiv3_schema_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiextensions::V1::ExternalDocumentation < ::KubeDSL::DSLObject
  def description(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def url(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::JSON < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).void }
  def initialize(&block); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig { returns(JSONType) }
  def serialize; end

  def value(val = T.unsafe(nil)); end

  JSONType = T.type_alias {
  T.any(T::Array[T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped])], T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
}
end

class KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps < ::KubeDSL::DSLObject
  def additional_items(*args); end
  def additional_properties(*args); end
  def all_of(elem_name = T.unsafe(nil), &block); end

  sig do
    params(
      elem_name: T.nilable(Symbol),
      block: T.nilable(T.proc.returns(KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps))
    ).returns(T::Array[KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps])
  end
  def all_ofs(elem_name = nil, &block); end

  def all_oves; end
  def any_of(elem_name = T.unsafe(nil), &block); end

  sig do
    params(
      elem_name: T.nilable(Symbol),
      block: T.nilable(T.proc.returns(KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps))
    ).returns(T::Array[KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps])
  end
  def any_ofs(elem_name = nil, &block); end

  def any_oves; end
  def default(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def definitions(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def dependencies(&block); end

  def description(*args); end
  def ena; end
  def enum(elem_name = T.unsafe(nil), &block); end

  sig do
    params(
      elem_name: T.nilable(Symbol),
      block: T.nilable(T.proc.returns(KubeDSL::DSL::Apiextensions::V1::JSON))
    ).returns(T::Array[KubeDSL::DSL::Apiextensions::V1::JSON])
  end
  def enums(elem_name = nil, &block); end

  def example(*args); end
  def exclusive_maximum(*args); end
  def exclusive_minimum(*args); end
  def external_docs(*args, &block); end
  def external_docs_present?; end
  def format(*args); end
  def id(*args); end
  def items(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def max_items(*args); end
  def max_length(*args); end
  def max_properties(*args); end
  def maximum(*args); end
  def min_items(*args); end
  def min_length(*args); end
  def min_properties(*args); end
  def minimum(*args); end
  def multiple_of(*args); end
  def not_field(*args, &block); end
  def not_field_present?; end
  def nullable(*args); end
  def one_of(elem_name = T.unsafe(nil), &block); end

  sig do
    params(
      elem_name: T.nilable(Symbol),
      block: T.nilable(T.proc.returns(KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps))
    ).returns(T::Array[KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps])
  end
  def one_ofs(elem_name = nil, &block); end

  def one_oves; end
  def pattern(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def pattern_properties(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def properties(&block); end

  def required(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def title(*args); end
  def type(*args); end
  def unique_items(*args); end
  def x_kubernetes_embedded_resource(*args); end
  def x_kubernetes_int_or_string(*args); end
  def x_kubernetes_list_map_keys(*args); end
  def x_kubernetes_list_type(*args); end
  def x_kubernetes_map_type(*args); end
  def x_kubernetes_preserve_unknown_fields(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::ServiceReference < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end
  def path(*args); end
  def port(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiextensions::V1::WebhookClientConfig < ::KubeDSL::DSLObject
  def ca_bundle(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service(*args, &block); end
  def service_present?; end
  def url(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::WebhookConversion < ::KubeDSL::DSLObject
  def client_config(*args, &block); end
  def client_config_present?; end
  def conversion_review_versions(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Apiregistration; end
module KubeDSL::DSL::Apiregistration::V1; end

class KubeDSL::DSL::Apiregistration::V1::APIService < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceSpec < ::KubeDSL::DSLObject
  def ca_bundle(*args); end
  def group(*args); end
  def group_priority_minimum(*args); end
  def insecure_skip_tls_verify(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service(*args, &block); end
  def service_present?; end
  def version(*args); end
  def version_priority(*args); end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiregistration::V1::ServiceReference < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end
  def port(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Apiserverinternal; end
module KubeDSL::DSL::Apiserverinternal::V1alpha1; end

class KubeDSL::DSL::Apiserverinternal::V1alpha1::ServerStorageVersion < ::KubeDSL::DSLObject
  def api_server_id(*args); end
  def decodable_versions(*args); end
  def encoding_version(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiserverinternal::V1alpha1::StorageVersion < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args); end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apiserverinternal::V1alpha1::StorageVersionCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def observed_generation(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apiserverinternal::V1alpha1::StorageVersionList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apiserverinternal::V1alpha1::StorageVersionStatus < ::KubeDSL::DSLObject
  def common_encoding_version(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_version(elem_name = T.unsafe(nil), &block); end
  def storage_versions; end
end

module KubeDSL::DSL::Apps; end
module KubeDSL::DSL::Apps::V1; end

class KubeDSL::DSL::Apps::V1::ControllerRevision < ::KubeDSL::DSLObject
  def data(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def revision(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::ControllerRevisionList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::DaemonSet < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apps::V1::DaemonSetCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::DaemonSetSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def min_ready_seconds(*args); end
  def revision_history_limit(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def template(*args, &block); end
  def template_present?; end
  def update_strategy(*args, &block); end
  def update_strategy_present?; end
end

class KubeDSL::DSL::Apps::V1::DaemonSetStatus < ::KubeDSL::DSLObject
  def collision_count(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def current_number_scheduled(*args); end
  def desired_number_scheduled(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def number_available(*args); end
  def number_misscheduled(*args); end
  def number_ready(*args); end
  def number_unavailable(*args); end
  def observed_generation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def updated_number_scheduled(*args); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetUpdateStrategy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def rolling_update(*args, &block); end
  def rolling_update_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::Deployment < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apps::V1::DeploymentCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def last_update_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::DeploymentList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::DeploymentSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def min_ready_seconds(*args); end
  def paused(*args); end
  def progress_deadline_seconds(*args); end
  def replicas(*args); end
  def revision_history_limit(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def strategy(*args, &block); end
  def strategy_present?; end
  def template(*args, &block); end
  def template_present?; end
end

class KubeDSL::DSL::Apps::V1::DeploymentStatus < ::KubeDSL::DSLObject
  def available_replicas(*args); end
  def collision_count(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  def observed_generation(*args); end
  def ready_replicas(*args); end
  def replicas(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def unavailable_replicas(*args); end
  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1::DeploymentStrategy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def rolling_update(*args, &block); end
  def rolling_update_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSet < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def min_ready_seconds(*args); end
  def replicas(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def template(*args, &block); end
  def template_present?; end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetStatus < ::KubeDSL::DSLObject
  def available_replicas(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def fully_labeled_replicas(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def observed_generation(*args); end
  def ready_replicas(*args); end
  def replicas(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::RollingUpdateDaemonSet < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max_surge(*args); end
  def max_unavailable(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::RollingUpdateDeployment < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max_surge(*args); end
  def max_unavailable(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::RollingUpdateStatefulSetStrategy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def partition(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::StatefulSet < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Apps::V1::StatefulSetCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Apps::V1::StatefulSetSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def min_ready_seconds(*args); end
  def pod_management_policy(*args); end
  def replicas(*args); end
  def revision_history_limit(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service_name(*args); end
  def template(*args, &block); end
  def template_present?; end
  def update_strategy(*args, &block); end
  def update_strategy_present?; end
  def volume_claim_template(elem_name = T.unsafe(nil), &block); end
  def volume_claim_templates; end
end

class KubeDSL::DSL::Apps::V1::StatefulSetStatus < ::KubeDSL::DSLObject
  def available_replicas(*args); end
  def collision_count(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def current_replicas(*args); end
  def current_revision(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def observed_generation(*args); end
  def ready_replicas(*args); end
  def replicas(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def update_revision(*args); end
  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetUpdateStrategy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def rolling_update(*args, &block); end
  def rolling_update_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

module KubeDSL::DSL::Authentication; end
module KubeDSL::DSL::Authentication::V1; end

class KubeDSL::DSL::Authentication::V1::BoundObjectReference < ::KubeDSL::DSLObject
  def api_version(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::Authentication::V1::TokenRequest < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Authentication::V1::TokenRequestSpec < ::KubeDSL::DSLObject
  def audiences(*args); end
  def bound_object_ref(*args, &block); end
  def bound_object_ref_present?; end
  def expiration_seconds(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Authentication::V1::TokenRequestStatus < ::KubeDSL::DSLObject
  def expiration_timestamp(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def token(*args); end
end

class KubeDSL::DSL::Authentication::V1::TokenReview < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Authentication::V1::TokenReviewSpec < ::KubeDSL::DSLObject
  def audiences(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def token(*args); end
end

class KubeDSL::DSL::Authentication::V1::TokenReviewStatus < ::KubeDSL::DSLObject
  def audiences(*args); end
  def authenticated(*args); end
  def error(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def user(*args, &block); end
  def user_present?; end
end

class KubeDSL::DSL::Authentication::V1::UserInfo < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def extra(&block); end

  def groups(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
  def username(*args); end
end

module KubeDSL::DSL::Authorization; end
module KubeDSL::DSL::Authorization::V1; end

class KubeDSL::DSL::Authorization::V1::LocalSubjectAccessReview < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Authorization::V1::NonResourceAttributes < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verb(*args); end
end

class KubeDSL::DSL::Authorization::V1::NonResourceRule < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_ur_ls(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verbs(*args); end
end

class KubeDSL::DSL::Authorization::V1::ResourceAttributes < ::KubeDSL::DSLObject
  def group(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end
  def resource(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subresource(*args); end
  def verb(*args); end
  def version(*args); end
end

class KubeDSL::DSL::Authorization::V1::ResourceRule < ::KubeDSL::DSLObject
  def api_groups(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def resource_names(*args); end
  def resources(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verbs(*args); end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReview < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReviewSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_attributes(*args, &block); end
  def non_resource_attributes_present?; end
  def resource_attributes(*args, &block); end
  def resource_attributes_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReview < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReviewSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def namespace(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReview < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReviewSpec < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def extra(&block); end

  def groups(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_attributes(*args, &block); end
  def non_resource_attributes_present?; end
  def resource_attributes(*args, &block); end
  def resource_attributes_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
  def user(*args); end
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReviewStatus < ::KubeDSL::DSLObject
  def allowed(*args); end
  def denied(*args); end
  def evaluation_error(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Authorization::V1::SubjectRulesReviewStatus < ::KubeDSL::DSLObject
  def evaluation_error(*args); end
  def incomplete(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_rule(elem_name = T.unsafe(nil), &block); end
  def non_resource_rules; end
  def resource_rule(elem_name = T.unsafe(nil), &block); end
  def resource_rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Autoscaling; end
module KubeDSL::DSL::Autoscaling::V1; end

class KubeDSL::DSL::Autoscaling::V1::CrossVersionObjectReference < ::KubeDSL::DSLObject
  def api_version(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscaler < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max_replicas(*args); end
  def min_replicas(*args); end
  def scale_target_ref(*args, &block); end
  def scale_target_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_cpu_utilization_percentage(*args); end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerStatus < ::KubeDSL::DSLObject
  def current_cpu_utilization_percentage(*args); end
  def current_replicas(*args); end
  def desired_replicas(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_scale_time(*args); end
  def observed_generation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V1::Scale < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Autoscaling::V1::ScaleSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def replicas(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V1::ScaleStatus < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def replicas(*args); end
  def selector(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Autoscaling::V2beta1; end

class KubeDSL::DSL::Autoscaling::V2beta1::ContainerResourceMetricSource < ::KubeDSL::DSLObject
  def container(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_average_utilization(*args); end
  def target_average_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ContainerResourceMetricStatus < ::KubeDSL::DSLObject
  def container(*args); end
  def current_average_utilization(*args); end
  def current_average_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::CrossVersionObjectReference < ::KubeDSL::DSLObject
  def api_version(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ExternalMetricSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metric_name(*args); end
  def metric_selector(*args, &block); end
  def metric_selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_average_value(*args); end
  def target_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ExternalMetricStatus < ::KubeDSL::DSLObject
  def current_average_value(*args); end
  def current_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric_name(*args); end
  def metric_selector(*args, &block); end
  def metric_selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscaler < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max_replicas(*args); end
  def metric(elem_name = T.unsafe(nil), &block); end
  def metrics; end
  def min_replicas(*args); end
  def scale_target_ref(*args, &block); end
  def scale_target_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def current_metric(elem_name = T.unsafe(nil), &block); end
  def current_metrics; end
  def current_replicas(*args); end
  def desired_replicas(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_scale_time(*args); end
  def observed_generation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::MetricSpec < ::KubeDSL::DSLObject
  def container_resource(*args, &block); end
  def container_resource_present?; end
  def external(*args, &block); end
  def external_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def object(*args, &block); end
  def object_present?; end
  def pods(*args, &block); end
  def pods_present?; end
  def resource(*args, &block); end
  def resource_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::MetricStatus < ::KubeDSL::DSLObject
  def container_resource(*args, &block); end
  def container_resource_present?; end
  def external(*args, &block); end
  def external_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def object(*args, &block); end
  def object_present?; end
  def pods(*args, &block); end
  def pods_present?; end
  def resource(*args, &block); end
  def resource_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ObjectMetricSource < ::KubeDSL::DSLObject
  def average_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric_name(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
  def target_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ObjectMetricStatus < ::KubeDSL::DSLObject
  def average_value(*args); end
  def current_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric_name(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::PodsMetricSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metric_name(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_average_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::PodsMetricStatus < ::KubeDSL::DSLObject
  def current_average_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric_name(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ResourceMetricSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_average_utilization(*args); end
  def target_average_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ResourceMetricStatus < ::KubeDSL::DSLObject
  def current_average_utilization(*args); end
  def current_average_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Autoscaling::V2beta2; end

class KubeDSL::DSL::Autoscaling::V2beta2::ContainerResourceMetricSource < ::KubeDSL::DSLObject
  def container(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ContainerResourceMetricStatus < ::KubeDSL::DSLObject
  def container(*args); end
  def current(*args, &block); end
  def current_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::CrossVersionObjectReference < ::KubeDSL::DSLObject
  def api_version(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ExternalMetricSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metric(*args, &block); end
  def metric_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ExternalMetricStatus < ::KubeDSL::DSLObject
  def current(*args, &block); end
  def current_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric(*args, &block); end
  def metric_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HPAScalingPolicy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def period_seconds(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
  def value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HPAScalingRules < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def policies; end
  def policy(elem_name = T.unsafe(nil), &block); end
  def select_policy(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def stabilization_window_seconds(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscaler < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerBehavior < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def scale_down(*args, &block); end
  def scale_down_present?; end
  def scale_up(*args, &block); end
  def scale_up_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerSpec < ::KubeDSL::DSLObject
  def behavior(*args, &block); end
  def behavior_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def max_replicas(*args); end
  def metric(elem_name = T.unsafe(nil), &block); end
  def metrics; end
  def min_replicas(*args); end
  def scale_target_ref(*args, &block); end
  def scale_target_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def current_metric(elem_name = T.unsafe(nil), &block); end
  def current_metrics; end
  def current_replicas(*args); end
  def desired_replicas(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_scale_time(*args); end
  def observed_generation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricIdentifier < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricSpec < ::KubeDSL::DSLObject
  def container_resource(*args, &block); end
  def container_resource_present?; end
  def external(*args, &block); end
  def external_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def object(*args, &block); end
  def object_present?; end
  def pods(*args, &block); end
  def pods_present?; end
  def resource(*args, &block); end
  def resource_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricStatus < ::KubeDSL::DSLObject
  def container_resource(*args, &block); end
  def container_resource_present?; end
  def external(*args, &block); end
  def external_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def object(*args, &block); end
  def object_present?; end
  def pods(*args, &block); end
  def pods_present?; end
  def resource(*args, &block); end
  def resource_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricTarget < ::KubeDSL::DSLObject
  def average_utilization(*args); end
  def average_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
  def value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricValueStatus < ::KubeDSL::DSLObject
  def average_utilization(*args); end
  def average_value(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ObjectMetricSource < ::KubeDSL::DSLObject
  def described_object(*args, &block); end
  def described_object_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric(*args, &block); end
  def metric_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ObjectMetricStatus < ::KubeDSL::DSLObject
  def current(*args, &block); end
  def current_present?; end
  def described_object(*args, &block); end
  def described_object_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric(*args, &block); end
  def metric_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::PodsMetricSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metric(*args, &block); end
  def metric_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::PodsMetricStatus < ::KubeDSL::DSLObject
  def current(*args, &block); end
  def current_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metric(*args, &block); end
  def metric_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ResourceMetricSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ResourceMetricStatus < ::KubeDSL::DSLObject
  def current(*args, &block); end
  def current_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Batch; end
module KubeDSL::DSL::Batch::V1; end

class KubeDSL::DSL::Batch::V1::CronJob < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Batch::V1::CronJobList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Batch::V1::CronJobSpec < ::KubeDSL::DSLObject
  def concurrency_policy(*args); end
  def failed_jobs_history_limit(*args); end
  def job_template(*args, &block); end
  def job_template_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def schedule(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def starting_deadline_seconds(*args); end
  def successful_jobs_history_limit(*args); end
  def suspend(*args); end
end

class KubeDSL::DSL::Batch::V1::CronJobStatus < ::KubeDSL::DSLObject
  def active(elem_name = T.unsafe(nil), &block); end
  def actives; end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_schedule_time(*args); end
  def last_successful_time(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Batch::V1::Job < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Batch::V1::JobCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_probe_time(*args); end
  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Batch::V1::JobList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Batch::V1::JobSpec < ::KubeDSL::DSLObject
  def active_deadline_seconds(*args); end
  def backoff_limit(*args); end
  def completion_mode(*args); end
  def completions(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def manual_selector(*args); end
  def parallelism(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def suspend(*args); end
  def template(*args, &block); end
  def template_present?; end
  def ttl_seconds_after_finished(*args); end
end

class KubeDSL::DSL::Batch::V1::JobStatus < ::KubeDSL::DSLObject
  def active(*args); end
  def completed_indexes(*args); end
  def completion_time(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def failed(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def start_time(*args); end
  def succeeded(*args); end
  def uncounted_terminated_pods(*args, &block); end
  def uncounted_terminated_pods_present?; end
end

class KubeDSL::DSL::Batch::V1::JobTemplateSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Batch::V1::UncountedTerminatedPods < ::KubeDSL::DSLObject
  def failed(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def succeeded(*args); end
end

module KubeDSL::DSL::Batch::V1beta1; end

class KubeDSL::DSL::Batch::V1beta1::CronJob < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Batch::V1beta1::CronJobList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Batch::V1beta1::CronJobSpec < ::KubeDSL::DSLObject
  def concurrency_policy(*args); end
  def failed_jobs_history_limit(*args); end
  def job_template(*args, &block); end
  def job_template_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def schedule(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def starting_deadline_seconds(*args); end
  def successful_jobs_history_limit(*args); end
  def suspend(*args); end
end

class KubeDSL::DSL::Batch::V1beta1::CronJobStatus < ::KubeDSL::DSLObject
  def active(elem_name = T.unsafe(nil), &block); end
  def actives; end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_schedule_time(*args); end
  def last_successful_time(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Batch::V1beta1::JobTemplateSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

module KubeDSL::DSL::Certificates; end
module KubeDSL::DSL::Certificates::V1; end

class KubeDSL::DSL::Certificates::V1::CertificateSigningRequest < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Certificates::V1::CertificateSigningRequestCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def last_update_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Certificates::V1::CertificateSigningRequestList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Certificates::V1::CertificateSigningRequestSpec < ::KubeDSL::DSLObject
  def expiration_seconds(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def extra(&block); end

  def groups(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def request(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def signer_name(*args); end
  def uid(*args); end
  def usages(*args); end
  def username(*args); end
end

class KubeDSL::DSL::Certificates::V1::CertificateSigningRequestStatus < ::KubeDSL::DSLObject
  def certificate(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Coordination; end
module KubeDSL::DSL::Coordination::V1; end

class KubeDSL::DSL::Coordination::V1::Lease < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Coordination::V1::LeaseList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Coordination::V1::LeaseSpec < ::KubeDSL::DSLObject
  def acquire_time(*args); end
  def holder_identity(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def lease_duration_seconds(*args); end
  def lease_transitions(*args); end
  def renew_time(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Discovery; end
module KubeDSL::DSL::Discovery::V1; end

class KubeDSL::DSL::Discovery::V1::Endpoint < ::KubeDSL::DSLObject
  def addresses(*args); end
  def conditions(*args, &block); end
  def conditions_present?; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def deprecated_topology(&block); end

  def hints(*args, &block); end
  def hints_present?; end
  def hostname(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_ref(*args, &block); end
  def target_ref_present?; end
  def zone(*args); end
end

class KubeDSL::DSL::Discovery::V1::EndpointConditions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def ready(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def serving(*args); end
  def terminating(*args); end
end

class KubeDSL::DSL::Discovery::V1::EndpointHints < ::KubeDSL::DSLObject
  def for_zone(elem_name = T.unsafe(nil), &block); end
  def for_zones; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1::EndpointPort < ::KubeDSL::DSLObject
  def app_protocol(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def port(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1::EndpointSlice < ::KubeDSL::DSLObject
  def address_type(*args); end
  def endpoint(elem_name = T.unsafe(nil), &block); end
  def endpoints; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1::EndpointSliceList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1::ForZone < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Discovery::V1beta1; end

class KubeDSL::DSL::Discovery::V1beta1::Endpoint < ::KubeDSL::DSLObject
  def addresses(*args); end
  def conditions(*args, &block); end
  def conditions_present?; end
  def hints(*args, &block); end
  def hints_present?; end
  def hostname(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_ref(*args, &block); end
  def target_ref_present?; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def topology(&block); end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointConditions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def ready(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def serving(*args); end
  def terminating(*args); end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointHints < ::KubeDSL::DSLObject
  def for_zone(elem_name = T.unsafe(nil), &block); end
  def for_zones; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointPort < ::KubeDSL::DSLObject
  def app_protocol(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def port(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointSlice < ::KubeDSL::DSLObject
  def address_type(*args); end
  def endpoint(elem_name = T.unsafe(nil), &block); end
  def endpoints; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointSliceList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Discovery::V1beta1::ForZone < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Events; end
module KubeDSL::DSL::Events::V1; end

class KubeDSL::DSL::Events::V1::Event < ::KubeDSL::DSLObject
  def action(*args); end
  def deprecated_count(*args); end
  def deprecated_first_timestamp(*args); end
  def deprecated_last_timestamp(*args); end
  def deprecated_source(*args, &block); end
  def deprecated_source_present?; end
  def event_time(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def note(*args); end
  def reason(*args); end
  def regarding(*args, &block); end
  def regarding_present?; end
  def related(*args, &block); end
  def related_present?; end
  def reporting_controller(*args); end
  def reporting_instance(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def series(*args, &block); end
  def series_present?; end
  def type(*args); end
end

class KubeDSL::DSL::Events::V1::EventList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Events::V1::EventSeries < ::KubeDSL::DSLObject
  def count(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_observed_time(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Events::V1beta1; end

class KubeDSL::DSL::Events::V1beta1::Event < ::KubeDSL::DSLObject
  def action(*args); end
  def deprecated_count(*args); end
  def deprecated_first_timestamp(*args); end
  def deprecated_last_timestamp(*args); end
  def deprecated_source(*args, &block); end
  def deprecated_source_present?; end
  def event_time(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def note(*args); end
  def reason(*args); end
  def regarding(*args, &block); end
  def regarding_present?; end
  def related(*args, &block); end
  def related_present?; end
  def reporting_controller(*args); end
  def reporting_instance(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def series(*args, &block); end
  def series_present?; end
  def type(*args); end
end

class KubeDSL::DSL::Events::V1beta1::EventList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Events::V1beta1::EventSeries < ::KubeDSL::DSLObject
  def count(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_observed_time(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Flowcontrol; end
module KubeDSL::DSL::Flowcontrol::V1beta1; end

class KubeDSL::DSL::Flowcontrol::V1beta1::FlowDistinguisherMethod < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::FlowSchema < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::FlowSchemaCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::FlowSchemaList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::FlowSchemaSpec < ::KubeDSL::DSLObject
  def distinguisher_method(*args, &block); end
  def distinguisher_method_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def matching_precedence(*args); end
  def priority_level_configuration(*args, &block); end
  def priority_level_configuration_present?; end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::FlowSchemaStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::GroupSubject < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::LimitResponse < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def queuing(*args, &block); end
  def queuing_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::LimitedPriorityLevelConfiguration < ::KubeDSL::DSLObject
  def assured_concurrency_shares(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def limit_response(*args, &block); end
  def limit_response_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::NonResourcePolicyRule < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_ur_ls(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verbs(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PolicyRulesWithSubjects < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_rule(elem_name = T.unsafe(nil), &block); end
  def non_resource_rules; end
  def resource_rule(elem_name = T.unsafe(nil), &block); end
  def resource_rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subject(elem_name = T.unsafe(nil), &block); end
  def subjects; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PriorityLevelConfiguration < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PriorityLevelConfigurationCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PriorityLevelConfigurationList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PriorityLevelConfigurationReference < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PriorityLevelConfigurationSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def limited(*args, &block); end
  def limited_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::PriorityLevelConfigurationStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::QueuingConfiguration < ::KubeDSL::DSLObject
  def hand_size(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def queue_length_limit(*args); end
  def queues(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::ResourcePolicyRule < ::KubeDSL::DSLObject
  def api_groups(*args); end
  def cluster_scope(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def namespaces(*args); end
  def resources(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verbs(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::ServiceAccountSubject < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::Subject < ::KubeDSL::DSLObject
  def group(*args, &block); end
  def group_present?; end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service_account(*args, &block); end
  def service_account_present?; end
  def user(*args, &block); end
  def user_present?; end
end

class KubeDSL::DSL::Flowcontrol::V1beta1::UserSubject < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Meta; end
module KubeDSL::DSL::Meta::V1; end

class KubeDSL::DSL::Meta::V1::APIGroup < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def preferred_version(*args, &block); end
  def preferred_version_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def server_address_by_client_cidr(elem_name = T.unsafe(nil), &block); end
  def server_address_by_client_cidrs; end
  def version(elem_name = T.unsafe(nil), &block); end
  def versions; end
end

class KubeDSL::DSL::Meta::V1::APIGroupList < ::KubeDSL::DSLObject
  def group(elem_name = T.unsafe(nil), &block); end
  def groups; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Meta::V1::APIResource < ::KubeDSL::DSLObject
  def categories(*args); end
  def group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespaced(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def short_names(*args); end
  def singular_name(*args); end
  def storage_version_hash(*args); end
  def verbs(*args); end
  def version(*args); end
end

class KubeDSL::DSL::Meta::V1::APIResourceList < ::KubeDSL::DSLObject
  def group_version(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def resource(elem_name = T.unsafe(nil), &block); end
  def resources; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Meta::V1::APIVersions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def server_address_by_client_cidr(elem_name = T.unsafe(nil), &block); end
  def server_address_by_client_cidrs; end
  def versions(*args); end
end

class KubeDSL::DSL::Meta::V1::Condition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def observed_generation(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::Meta::V1::DeleteOptions < ::KubeDSL::DSLObject
  def api_version(*args); end
  def dry_run(*args); end
  def grace_period_seconds(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def orphan_dependents(*args); end
  def preconditions(*args, &block); end
  def preconditions_present?; end
  def propagation_policy(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Meta::V1::GroupVersionForDiscovery < ::KubeDSL::DSLObject
  def group_version(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def version(*args); end
end

class KubeDSL::DSL::Meta::V1::LabelSelector < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def match_expression(elem_name = T.unsafe(nil), &block); end
  def match_expressions; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def match_labels(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Meta::V1::LabelSelectorRequirement < ::KubeDSL::DSLObject
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def operator(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def values(*args); end
end

class KubeDSL::DSL::Meta::V1::ListMeta < ::KubeDSL::DSLObject
  def continue(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def remaining_item_count(*args); end
  def resource_version(*args); end
  def self_link(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Meta::V1::ManagedFieldsEntry < ::KubeDSL::DSLObject
  def api_version(*args); end
  def fields_type(*args); end
  def fields_v1(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def manager(*args); end
  def operation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subresource(*args); end
  def time(*args); end
end

class KubeDSL::DSL::Meta::V1::ObjectMeta < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def annotations(&block); end

  def cluster_name(*args); end
  def creation_timestamp(*args); end
  def deletion_grace_period_seconds(*args); end
  def deletion_timestamp(*args); end
  def finalizers(*args); end
  def generate_name(*args); end
  def generation(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def labels(&block); end

  def managed_field(elem_name = T.unsafe(nil), &block); end
  def managed_fields; end
  def name(*args); end
  def namespace(*args); end
  def owner_reference(elem_name = T.unsafe(nil), &block); end
  def owner_references; end
  def resource_version(*args); end
  def self_link(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::OwnerReference < ::KubeDSL::DSLObject
  def api_version(*args); end
  def block_owner_deletion(*args); end
  def controller(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::Preconditions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def resource_version(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::ServerAddressByClientCIDR < ::KubeDSL::DSLObject
  def client_cidr(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def server_address(*args); end
end

class KubeDSL::DSL::Meta::V1::Status < ::KubeDSL::DSLObject
  def code(*args); end
  def details(*args, &block); end
  def details_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end
  def metadata(*args, &block); end
  def metadata_present?; end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
end

class KubeDSL::DSL::Meta::V1::StatusCause < ::KubeDSL::DSLObject
  def field(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Meta::V1::StatusDetails < ::KubeDSL::DSLObject
  def cause(elem_name = T.unsafe(nil), &block); end
  def causes; end
  def group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def retry_after_seconds(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::WatchEvent < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def object(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

module KubeDSL::DSL::Networking; end
module KubeDSL::DSL::Networking::V1; end

class KubeDSL::DSL::Networking::V1::HTTPIngressPath < ::KubeDSL::DSLObject
  def backend(*args, &block); end
  def backend_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end
  def path_type(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::HTTPIngressRuleValue < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def path(elem_name = T.unsafe(nil), &block); end
  def paths; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IPBlock < ::KubeDSL::DSLObject
  def cidr(*args); end
  def except(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::Ingress < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Networking::V1::IngressBackend < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def resource(*args, &block); end
  def resource_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service(*args, &block); end
  def service_present?; end
end

class KubeDSL::DSL::Networking::V1::IngressClass < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Networking::V1::IngressClassList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressClassParametersReference < ::KubeDSL::DSLObject
  def api_group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end
  def scope(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressClassSpec < ::KubeDSL::DSLObject
  def controller(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def parameters(*args, &block); end
  def parameters_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressRule < ::KubeDSL::DSLObject
  def host(*args); end
  def http(*args, &block); end
  def http_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressServiceBackend < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def port(*args, &block); end
  def port_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressSpec < ::KubeDSL::DSLObject
  def default_backend(*args, &block); end
  def default_backend_present?; end
  def ingress_class_name(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def tls(elem_name = T.unsafe(nil), &block); end
  def tlses; end
end

class KubeDSL::DSL::Networking::V1::IngressStatus < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def load_balancer(*args, &block); end
  def load_balancer_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::IngressTLS < ::KubeDSL::DSLObject
  def hosts(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def secret_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyEgressRule < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def to(elem_name = T.unsafe(nil), &block); end
  def tos; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyIngressRule < ::KubeDSL::DSLObject
  def from(elem_name = T.unsafe(nil), &block); end
  def froms; end

  sig { returns(Symbol) }
  def kind_sym; end

  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyPeer < ::KubeDSL::DSLObject
  def ip_block(*args, &block); end
  def ip_block_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def namespace_selector(*args, &block); end
  def namespace_selector_present?; end
  def pod_selector(*args, &block); end
  def pod_selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyPort < ::KubeDSL::DSLObject
  def end_port(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def port(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicySpec < ::KubeDSL::DSLObject
  def egress(elem_name = T.unsafe(nil), &block); end
  def egresses; end
  def ingress(elem_name = T.unsafe(nil), &block); end
  def ingresses; end

  sig { returns(Symbol) }
  def kind_sym; end

  def pod_selector(*args, &block); end
  def pod_selector_present?; end
  def policy_types(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Networking::V1::ServiceBackendPort < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def number(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Node; end
module KubeDSL::DSL::Node::V1; end

class KubeDSL::DSL::Node::V1::Overhead < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Node::V1::RuntimeClass < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Node::V1::RuntimeClassList < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Node::V1::Scheduling < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

module KubeDSL::DSL::Node::V1alpha1; end

class KubeDSL::DSL::Node::V1alpha1::Overhead < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def pod_fixed(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClass < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClassList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClassSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def overhead(*args, &block); end
  def overhead_present?; end
  def runtime_handler(*args); end
  def scheduling(*args, &block); end
  def scheduling_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Node::V1alpha1::Scheduling < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def node_selector(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def toleration(elem_name = T.unsafe(nil), &block); end
  def tolerations; end
end

module KubeDSL::DSL::Node::V1beta1; end

class KubeDSL::DSL::Node::V1beta1::Overhead < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def pod_fixed(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Node::V1beta1::RuntimeClass < ::KubeDSL::DSLObject
  def handler(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def overhead(*args, &block); end
  def overhead_present?; end
  def scheduling(*args, &block); end
  def scheduling_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Node::V1beta1::RuntimeClassList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Node::V1beta1::Scheduling < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def node_selector(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def toleration(elem_name = T.unsafe(nil), &block); end
  def tolerations; end
end

module KubeDSL::DSL::Pkg; end
module KubeDSL::DSL::Pkg::Version; end

class KubeDSL::DSL::Pkg::Version::Info < ::KubeDSL::DSLObject
  def build_date(*args); end
  def compiler(*args); end
  def git_commit(*args); end
  def git_tree_state(*args); end
  def git_version(*args); end
  def go_version(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def major(*args); end
  def minor(*args); end
  def platform(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Policy; end
module KubeDSL::DSL::Policy::V1; end

class KubeDSL::DSL::Policy::V1::Eviction < ::KubeDSL::DSLObject
  def delete_options(*args, &block); end
  def delete_options_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1::PodDisruptionBudget < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Policy::V1::PodDisruptionBudgetList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1::PodDisruptionBudgetSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max_unavailable(*args); end
  def min_available(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1::PodDisruptionBudgetStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def current_healthy(*args); end
  def desired_healthy(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def disrupted_pods(&block); end

  def disruptions_allowed(*args); end
  def expected_pods(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def observed_generation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Policy::V1beta1; end

class KubeDSL::DSL::Policy::V1beta1::AllowedCSIDriver < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::AllowedFlexVolume < ::KubeDSL::DSLObject
  def driver(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::AllowedHostPath < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def path_prefix(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::FSGroupStrategyOptions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def range(elem_name = T.unsafe(nil), &block); end
  def ranges; end
  def rule(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::HostPortRange < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max(*args); end
  def min(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::IDRange < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max(*args); end
  def min(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudget < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def max_unavailable(*args); end
  def min_available(*args); end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def current_healthy(*args); end
  def desired_healthy(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def disrupted_pods(&block); end

  def disruptions_allowed(*args); end
  def expected_pods(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def observed_generation(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicy < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicyList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicySpec < ::KubeDSL::DSLObject
  def allow_privilege_escalation(*args); end
  def allowed_capabilities(*args); end
  def allowed_csi_driver(elem_name = T.unsafe(nil), &block); end
  def allowed_csi_drivers; end
  def allowed_flex_volume(elem_name = T.unsafe(nil), &block); end
  def allowed_flex_volumes; end
  def allowed_host_path(elem_name = T.unsafe(nil), &block); end
  def allowed_host_paths; end
  def allowed_proc_mount_types(*args); end
  def allowed_unsafe_sysctls(*args); end
  def default_add_capabilities(*args); end
  def default_allow_privilege_escalation(*args); end
  def forbidden_sysctls(*args); end
  def fs_group(*args, &block); end
  def fs_group_present?; end
  def host_ipc(*args); end
  def host_network(*args); end
  def host_pid(*args); end
  def host_port(elem_name = T.unsafe(nil), &block); end
  def host_ports; end

  sig { returns(Symbol) }
  def kind_sym; end

  def privileged(*args); end
  def read_only_root_filesystem(*args); end
  def required_drop_capabilities(*args); end
  def run_as_group(*args, &block); end
  def run_as_group_present?; end
  def run_as_user(*args, &block); end
  def run_as_user_present?; end
  def runtime_class(*args, &block); end
  def runtime_class_present?; end
  def se_linux(*args, &block); end
  def se_linux_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def supplemental_groups(*args, &block); end
  def supplemental_groups_present?; end
  def volumes(*args); end
end

class KubeDSL::DSL::Policy::V1beta1::RunAsGroupStrategyOptions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def range(elem_name = T.unsafe(nil), &block); end
  def ranges; end
  def rule(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::RunAsUserStrategyOptions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def range(elem_name = T.unsafe(nil), &block); end
  def ranges; end
  def rule(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::RuntimeClassStrategyOptions < ::KubeDSL::DSLObject
  def allowed_runtime_class_names(*args); end
  def default_runtime_class_name(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::SELinuxStrategyOptions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def rule(*args); end
  def se_linux_options(*args, &block); end
  def se_linux_options_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Policy::V1beta1::SupplementalGroupsStrategyOptions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def range(elem_name = T.unsafe(nil), &block); end
  def ranges; end
  def rule(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Rbac; end
module KubeDSL::DSL::Rbac::V1; end

class KubeDSL::DSL::Rbac::V1::AggregationRule < ::KubeDSL::DSLObject
  def cluster_role_selector(elem_name = T.unsafe(nil), &block); end
  def cluster_role_selectors; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::ClusterRole < ::KubeDSL::DSLObject
  def aggregation_rule(*args, &block); end
  def aggregation_rule_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleBinding < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def role_ref(*args, &block); end
  def role_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subject(elem_name = T.unsafe(nil), &block); end
  def subjects; end
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleBindingList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::PolicyRule < ::KubeDSL::DSLObject
  def api_groups(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_ur_ls(*args); end
  def resource_names(*args); end
  def resources(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verbs(*args); end
end

class KubeDSL::DSL::Rbac::V1::Role < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::RoleBinding < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def role_ref(*args, &block); end
  def role_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subject(elem_name = T.unsafe(nil), &block); end
  def subjects; end
end

class KubeDSL::DSL::Rbac::V1::RoleBindingList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::RoleList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::RoleRef < ::KubeDSL::DSLObject
  def api_group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1::Subject < ::KubeDSL::DSLObject
  def api_group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Rbac::V1alpha1; end

class KubeDSL::DSL::Rbac::V1alpha1::AggregationRule < ::KubeDSL::DSLObject
  def cluster_role_selector(elem_name = T.unsafe(nil), &block); end
  def cluster_role_selectors; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRole < ::KubeDSL::DSLObject
  def aggregation_rule(*args, &block); end
  def aggregation_rule_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleBinding < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def role_ref(*args, &block); end
  def role_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subject(elem_name = T.unsafe(nil), &block); end
  def subjects; end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleBindingList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::PolicyRule < ::KubeDSL::DSLObject
  def api_groups(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def non_resource_ur_ls(*args); end
  def resource_names(*args); end
  def resources(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def verbs(*args); end
end

class KubeDSL::DSL::Rbac::V1alpha1::Role < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def rule(elem_name = T.unsafe(nil), &block); end
  def rules; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleBinding < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def role_ref(*args, &block); end
  def role_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subject(elem_name = T.unsafe(nil), &block); end
  def subjects; end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleBindingList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleRef < ::KubeDSL::DSLObject
  def api_group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Rbac::V1alpha1::Subject < ::KubeDSL::DSLObject
  def api_version(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Scheduling; end
module KubeDSL::DSL::Scheduling::V1; end

class KubeDSL::DSL::Scheduling::V1::PriorityClass < ::KubeDSL::DSLObject
  def description(*args); end
  def global_default(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def preemption_policy(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
end

class KubeDSL::DSL::Scheduling::V1::PriorityClassList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Scheduling::V1alpha1; end

class KubeDSL::DSL::Scheduling::V1alpha1::PriorityClass < ::KubeDSL::DSLObject
  def description(*args); end
  def global_default(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def preemption_policy(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
end

class KubeDSL::DSL::Scheduling::V1alpha1::PriorityClassList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Storage; end
module KubeDSL::DSL::Storage::V1; end

class KubeDSL::DSL::Storage::V1::CSIDriver < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Storage::V1::CSIDriverList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::CSIDriverSpec < ::KubeDSL::DSLObject
  def attach_required(*args); end
  def fs_group_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def pod_info_on_mount(*args); end
  def requires_republish(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_capacity(*args); end
  def token_request(elem_name = T.unsafe(nil), &block); end
  def token_requests; end
  def volume_lifecycle_modes(*args); end
end

class KubeDSL::DSL::Storage::V1::CSINode < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::Storage::V1::CSINodeDriver < ::KubeDSL::DSLObject
  def allocatable(*args, &block); end
  def allocatable_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def node_id(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def topology_keys(*args); end
end

class KubeDSL::DSL::Storage::V1::CSINodeList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::CSINodeSpec < ::KubeDSL::DSLObject
  def driver(elem_name = T.unsafe(nil), &block); end
  def drivers; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::StorageClass < ::KubeDSL::DSLObject
  def allow_volume_expansion(*args); end
  def allowed_topologies; end
  def allowed_topology(elem_name = T.unsafe(nil), &block); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def mount_options(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def parameters(&block); end

  def provisioner(*args); end
  def reclaim_policy(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_binding_mode(*args); end
end

class KubeDSL::DSL::Storage::V1::StorageClassList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::TokenRequest < ::KubeDSL::DSLObject
  def audience(*args); end
  def expiration_seconds(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachment < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentSource < ::KubeDSL::DSLObject
  def inline_volume_spec(*args, &block); end
  def inline_volume_spec_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def persistent_volume_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentSpec < ::KubeDSL::DSLObject
  def attacher(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def source(*args, &block); end
  def source_present?; end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentStatus < ::KubeDSL::DSLObject
  def attach_error(*args, &block); end
  def attach_error_present?; end
  def attached(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def attachment_metadata(&block); end

  def detach_error(*args, &block); end
  def detach_error_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1::VolumeError < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def time(*args); end
end

class KubeDSL::DSL::Storage::V1::VolumeNodeResources < ::KubeDSL::DSLObject
  def count(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::Storage::V1alpha1; end

class KubeDSL::DSL::Storage::V1alpha1::CSIStorageCapacity < ::KubeDSL::DSLObject
  def capacity(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def maximum_volume_size(*args); end
  def metadata(*args, &block); end
  def metadata_present?; end
  def node_topology(*args, &block); end
  def node_topology_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_class_name(*args); end
end

class KubeDSL::DSL::Storage::V1alpha1::CSIStorageCapacityList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachment < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentSource < ::KubeDSL::DSLObject
  def inline_volume_spec(*args, &block); end
  def inline_volume_spec_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def persistent_volume_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentSpec < ::KubeDSL::DSLObject
  def attacher(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def source(*args, &block); end
  def source_present?; end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentStatus < ::KubeDSL::DSLObject
  def attach_error(*args, &block); end
  def attach_error_present?; end
  def attached(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def attachment_metadata(&block); end

  def detach_error(*args, &block); end
  def detach_error_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeError < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def time(*args); end
end

module KubeDSL::DSL::Storage::V1beta1; end

class KubeDSL::DSL::Storage::V1beta1::CSIStorageCapacity < ::KubeDSL::DSLObject
  def capacity(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def maximum_volume_size(*args); end
  def metadata(*args, &block); end
  def metadata_present?; end
  def node_topology(*args, &block); end
  def node_topology_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_class_name(*args); end
end

class KubeDSL::DSL::Storage::V1beta1::CSIStorageCapacityList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

module KubeDSL::DSL::V1; end

class KubeDSL::DSL::V1::AWSElasticBlockStoreVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def partition(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::Affinity < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def node_affinity(*args, &block); end
  def node_affinity_present?; end
  def pod_affinity(*args, &block); end
  def pod_affinity_present?; end
  def pod_anti_affinity(*args, &block); end
  def pod_anti_affinity_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::AttachedVolume < ::KubeDSL::DSLObject
  def device_path(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::AzureDiskVolumeSource < ::KubeDSL::DSLObject
  def caching_mode(*args); end
  def disk_name(*args); end
  def disk_uri(*args); end
  def fs_type(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::AzureFilePersistentVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def secret_name(*args); end
  def secret_namespace(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def share_name(*args); end
end

class KubeDSL::DSL::V1::AzureFileVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def secret_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def share_name(*args); end
end

class KubeDSL::DSL::V1::Binding < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target(*args, &block); end
  def target_present?; end
end

class KubeDSL::DSL::V1::CSIPersistentVolumeSource < ::KubeDSL::DSLObject
  def controller_expand_secret_ref(*args, &block); end
  def controller_expand_secret_ref_present?; end
  def controller_publish_secret_ref(*args, &block); end
  def controller_publish_secret_ref_present?; end
  def driver(*args); end
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_publish_secret_ref(*args, &block); end
  def node_publish_secret_ref_present?; end
  def node_stage_secret_ref(*args, &block); end
  def node_stage_secret_ref_present?; end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def volume_attributes(&block); end

  def volume_handle(*args); end
end

class KubeDSL::DSL::V1::CSIVolumeSource < ::KubeDSL::DSLObject
  def driver(*args); end
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_publish_secret_ref(*args, &block); end
  def node_publish_secret_ref_present?; end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def volume_attributes(&block); end
end

class KubeDSL::DSL::V1::Capabilities < ::KubeDSL::DSLObject
  def add(*args); end
  def drop(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::CephFSPersistentVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def monitors(*args); end
  def path(*args); end
  def read_only(*args); end
  def secret_file(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def user(*args); end
end

class KubeDSL::DSL::V1::CephFSVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def monitors(*args); end
  def path(*args); end
  def read_only(*args); end
  def secret_file(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def user(*args); end
end

class KubeDSL::DSL::V1::CinderPersistentVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::CinderVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::ClientIPConfig < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::V1::ComponentCondition < ::KubeDSL::DSLObject
  def error(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::V1::ComponentStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ComponentStatusList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ConfigMap < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def binary_data(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def data(&block); end

  def immutable(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ConfigMapEnvSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ConfigMapKeySelector < ::KubeDSL::DSLObject
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ConfigMapList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ConfigMapNodeConfigSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def kubelet_config_key(*args); end
  def name(*args); end
  def namespace(*args); end
  def resource_version(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::V1::ConfigMapProjection < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ConfigMapVolumeSource < ::KubeDSL::DSLObject
  def default_mode(*args); end
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Container < ::KubeDSL::DSLObject
  def args(*args); end
  def command(*args); end
  def env(elem_name = T.unsafe(nil), &block); end
  def env_from(elem_name = T.unsafe(nil), &block); end
  def env_froms; end
  def envs; end
  def image(*args); end
  def image_pull_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def lifecycle(*args, &block); end
  def lifecycle_present?; end
  def liveness_probe(*args, &block); end
  def liveness_probe_present?; end
  def name(*args); end
  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end
  def readiness_probe(*args, &block); end
  def readiness_probe_present?; end
  def resources(*args, &block); end
  def resources_present?; end
  def security_context(*args, &block); end
  def security_context_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def startup_probe(*args, &block); end
  def startup_probe_present?; end
  def stdin(*args); end
  def stdin_once(*args); end
  def termination_message_path(*args); end
  def termination_message_policy(*args); end
  def tty(*args); end
  def volume_device(elem_name = T.unsafe(nil), &block); end
  def volume_devices; end
  def volume_mount(elem_name = T.unsafe(nil), &block); end
  def volume_mounts; end
  def working_dir(*args); end
end

class KubeDSL::DSL::V1::ContainerImage < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def names(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def size_bytes(*args); end
end

class KubeDSL::DSL::V1::ContainerPort < ::KubeDSL::DSLObject
  def container_port(*args); end
  def host_ip(*args); end
  def host_port(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ContainerState < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def running(*args, &block); end
  def running_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def terminated(*args, &block); end
  def terminated_present?; end
  def waiting(*args, &block); end
  def waiting_present?; end
end

class KubeDSL::DSL::V1::ContainerStateRunning < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def started_at(*args); end
end

class KubeDSL::DSL::V1::ContainerStateTerminated < ::KubeDSL::DSLObject
  def container_id(*args); end
  def exit_code(*args); end
  def finished_at(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def signal(*args); end
  def started_at(*args); end
end

class KubeDSL::DSL::V1::ContainerStateWaiting < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ContainerStatus < ::KubeDSL::DSLObject
  def container_id(*args); end
  def image(*args); end
  def image_id(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_state(*args, &block); end
  def last_state_present?; end
  def name(*args); end
  def ready(*args); end
  def restart_count(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def started(*args); end
  def state(*args, &block); end
  def state_present?; end
end

class KubeDSL::DSL::V1::DaemonEndpoint < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def port(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::DownwardAPIProjection < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::DownwardAPIVolumeFile < ::KubeDSL::DSLObject
  def field_ref(*args, &block); end
  def field_ref_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def mode(*args); end
  def path(*args); end
  def resource_field_ref(*args, &block); end
  def resource_field_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::DownwardAPIVolumeSource < ::KubeDSL::DSLObject
  def default_mode(*args); end
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EmptyDirVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def medium(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def size_limit(*args); end
end

class KubeDSL::DSL::V1::EndpointAddress < ::KubeDSL::DSLObject
  def hostname(*args); end
  def ip(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_ref(*args, &block); end
  def target_ref_present?; end
end

class KubeDSL::DSL::V1::EndpointPort < ::KubeDSL::DSLObject
  def app_protocol(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def port(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EndpointSubset < ::KubeDSL::DSLObject
  def address(elem_name = T.unsafe(nil), &block); end
  def addresses; end

  sig { returns(Symbol) }
  def kind_sym; end

  def not_ready_address(elem_name = T.unsafe(nil), &block); end
  def not_ready_addresses; end
  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Endpoints < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def subset(elem_name = T.unsafe(nil), &block); end
  def subsets; end
end

class KubeDSL::DSL::V1::EndpointsList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EnvFromSource < ::KubeDSL::DSLObject
  def config_map_ref(*args, &block); end
  def config_map_ref_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def prefix(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EnvVar < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
  def value_from(*args, &block); end
  def value_from_present?; end
end

class KubeDSL::DSL::V1::EnvVarSource < ::KubeDSL::DSLObject
  def config_map_key_ref(*args, &block); end
  def config_map_key_ref_present?; end
  def field_ref(*args, &block); end
  def field_ref_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def resource_field_ref(*args, &block); end
  def resource_field_ref_present?; end
  def secret_key_ref(*args, &block); end
  def secret_key_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EphemeralContainer < ::KubeDSL::DSLObject
  def args(*args); end
  def command(*args); end
  def env(elem_name = T.unsafe(nil), &block); end
  def env_from(elem_name = T.unsafe(nil), &block); end
  def env_froms; end
  def envs; end
  def image(*args); end
  def image_pull_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def lifecycle(*args, &block); end
  def lifecycle_present?; end
  def liveness_probe(*args, &block); end
  def liveness_probe_present?; end
  def name(*args); end
  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end
  def readiness_probe(*args, &block); end
  def readiness_probe_present?; end
  def resources(*args, &block); end
  def resources_present?; end
  def security_context(*args, &block); end
  def security_context_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def startup_probe(*args, &block); end
  def startup_probe_present?; end
  def stdin(*args); end
  def stdin_once(*args); end
  def target_container_name(*args); end
  def termination_message_path(*args); end
  def termination_message_policy(*args); end
  def tty(*args); end
  def volume_device(elem_name = T.unsafe(nil), &block); end
  def volume_devices; end
  def volume_mount(elem_name = T.unsafe(nil), &block); end
  def volume_mounts; end
  def working_dir(*args); end
end

class KubeDSL::DSL::V1::EphemeralVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_claim_template(*args, &block); end
  def volume_claim_template_present?; end
end

class KubeDSL::DSL::V1::Event < ::KubeDSL::DSLObject
  def action(*args); end
  def count(*args); end
  def event_time(*args); end
  def first_timestamp(*args); end
  def involved_object(*args, &block); end
  def involved_object_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_timestamp(*args); end
  def message(*args); end
  def metadata(*args, &block); end
  def metadata_present?; end
  def reason(*args); end
  def related(*args, &block); end
  def related_present?; end
  def reporting_component(*args); end
  def reporting_instance(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def series(*args, &block); end
  def series_present?; end
  def source(*args, &block); end
  def source_present?; end
  def type(*args); end
end

class KubeDSL::DSL::V1::EventList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EventSeries < ::KubeDSL::DSLObject
  def count(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_observed_time(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::EventSource < ::KubeDSL::DSLObject
  def component(*args); end
  def host(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ExecAction < ::KubeDSL::DSLObject
  def command(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::FCVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def lun(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_ww_ns(*args); end
  def wwids(*args); end
end

class KubeDSL::DSL::V1::FlexPersistentVolumeSource < ::KubeDSL::DSLObject
  def driver(*args); end
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def options(&block); end

  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::FlexVolumeSource < ::KubeDSL::DSLObject
  def driver(*args); end
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def options(&block); end

  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::FlockerVolumeSource < ::KubeDSL::DSLObject
  def dataset_name(*args); end
  def dataset_uuid(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::GCEPersistentDiskVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def partition(*args); end
  def pd_name(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::GitRepoVolumeSource < ::KubeDSL::DSLObject
  def directory(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def repository(*args); end
  def revision(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::GlusterfsPersistentVolumeSource < ::KubeDSL::DSLObject
  def endpoints(*args); end
  def endpoints_namespace(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::GlusterfsVolumeSource < ::KubeDSL::DSLObject
  def endpoints(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::HTTPGetAction < ::KubeDSL::DSLObject
  def host(*args); end
  def http_header(elem_name = T.unsafe(nil), &block); end
  def http_headers; end

  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end
  def port(*args); end
  def scheme(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::HTTPHeader < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
end

class KubeDSL::DSL::V1::Handler < ::KubeDSL::DSLObject
  def exec(*args, &block); end
  def exec_present?; end
  def http_get(*args, &block); end
  def http_get_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def tcp_socket(*args, &block); end
  def tcp_socket_present?; end
end

class KubeDSL::DSL::V1::HostAlias < ::KubeDSL::DSLObject
  def hostnames(*args); end
  def ip(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::HostPathVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::V1::ISCSIPersistentVolumeSource < ::KubeDSL::DSLObject
  def chap_auth_discovery(*args); end
  def chap_auth_session(*args); end
  def fs_type(*args); end
  def initiator_name(*args); end
  def iqn(*args); end
  def iscsi_interface(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def lun(*args); end
  def portals(*args); end
  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_portal(*args); end
end

class KubeDSL::DSL::V1::ISCSIVolumeSource < ::KubeDSL::DSLObject
  def chap_auth_discovery(*args); end
  def chap_auth_session(*args); end
  def fs_type(*args); end
  def initiator_name(*args); end
  def iqn(*args); end
  def iscsi_interface(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def lun(*args); end
  def portals(*args); end
  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_portal(*args); end
end

class KubeDSL::DSL::V1::KeyToPath < ::KubeDSL::DSLObject
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def mode(*args); end
  def path(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Lifecycle < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def post_start(*args, &block); end
  def post_start_present?; end
  def pre_stop(*args, &block); end
  def pre_stop_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::LimitRange < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::V1::LimitRangeItem < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def default(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def default_request(&block); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def max(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def max_limit_request_ratio(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def min(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::V1::LimitRangeList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::LimitRangeSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def limit(elem_name = T.unsafe(nil), &block); end
  def limits; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::LoadBalancerIngress < ::KubeDSL::DSLObject
  def hostname(*args); end
  def ip(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::LoadBalancerStatus < ::KubeDSL::DSLObject
  def ingress(elem_name = T.unsafe(nil), &block); end
  def ingresses; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::LocalObjectReference < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::LocalVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NFSVolumeSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def server(*args); end
end

class KubeDSL::DSL::V1::Namespace < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::NamespaceCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::V1::NamespaceList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NamespaceSpec < ::KubeDSL::DSLObject
  def finalizers(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NamespaceStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  def phase(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Node < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::NodeAddress < ::KubeDSL::DSLObject
  def address(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::V1::NodeAffinity < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def preferred_during_scheduling_ignored_during_execution(elem_name = T.unsafe(nil), &block); end
  def preferred_during_scheduling_ignored_during_executions; end
  def required_during_scheduling_ignored_during_execution(*args, &block); end
  def required_during_scheduling_ignored_during_execution_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_heartbeat_time(*args); end
  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::V1::NodeConfigSource < ::KubeDSL::DSLObject
  def config_map(*args, &block); end
  def config_map_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeConfigStatus < ::KubeDSL::DSLObject
  def active(*args, &block); end
  def active_present?; end
  def assigned(*args, &block); end
  def assigned_present?; end
  def error(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def last_known_good(*args, &block); end
  def last_known_good_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeDaemonEndpoints < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def kubelet_endpoint(*args, &block); end
  def kubelet_endpoint_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeSelector < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def node_selector_term(elem_name = T.unsafe(nil), &block); end
  def node_selector_terms; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeSelectorRequirement < ::KubeDSL::DSLObject
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def operator(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def values(*args); end
end

class KubeDSL::DSL::V1::NodeSelectorTerm < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def match_expression(elem_name = T.unsafe(nil), &block); end
  def match_expressions; end
  def match_field(elem_name = T.unsafe(nil), &block); end
  def match_fields; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::NodeSpec < ::KubeDSL::DSLObject
  def config_source(*args, &block); end
  def config_source_present?; end
  def external_id(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def pod_cid_rs(*args); end
  def pod_cidr(*args); end
  def provider_id(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def taint(elem_name = T.unsafe(nil), &block); end
  def taints; end
  def unschedulable(*args); end
end

class KubeDSL::DSL::V1::NodeStatus < ::KubeDSL::DSLObject
  def address(elem_name = T.unsafe(nil), &block); end
  def addresses; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def allocatable(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def capacity(&block); end

  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def config(*args, &block); end
  def config_present?; end
  def daemon_endpoints(*args, &block); end
  def daemon_endpoints_present?; end
  def image(elem_name = T.unsafe(nil), &block); end
  def images; end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_info(*args, &block); end
  def node_info_present?; end
  def phase(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volumes_attached(elem_name = T.unsafe(nil), &block); end
  def volumes_attacheds; end
  def volumes_in_use(*args); end
end

class KubeDSL::DSL::V1::NodeSystemInfo < ::KubeDSL::DSLObject
  def architecture(*args); end
  def boot_id(*args); end
  def container_runtime_version(*args); end
  def kernel_version(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def kube_proxy_version(*args); end
  def kubelet_version(*args); end
  def machine_id(*args); end
  def operating_system(*args); end
  def os_image(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def system_uuid(*args); end
end

class KubeDSL::DSL::V1::ObjectFieldSelector < ::KubeDSL::DSLObject
  def api_version(*args); end
  def field_path(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ObjectReference < ::KubeDSL::DSLObject
  def api_version(*args); end
  def field_path(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end
  def resource_version(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def uid(*args); end
end

class KubeDSL::DSL::V1::PersistentVolume < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::PersistentVolumeClaim < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_probe_time(*args); end
  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimSpec < ::KubeDSL::DSLObject
  def access_modes(*args); end
  def data_source(*args, &block); end
  def data_source_present?; end
  def data_source_ref(*args, &block); end
  def data_source_ref_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def resources(*args, &block); end
  def resources_present?; end
  def selector(*args, &block); end
  def selector_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_class_name(*args); end
  def volume_mode(*args); end
  def volume_name(*args); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimStatus < ::KubeDSL::DSLObject
  def access_modes(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def capacity(&block); end

  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  def phase(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimTemplate < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimVolumeSource < ::KubeDSL::DSLObject
  def claim_name(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PersistentVolumeList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PersistentVolumeSpec < ::KubeDSL::DSLObject
  def access_modes(*args); end
  def aws_elastic_block_store(*args, &block); end
  def aws_elastic_block_store_present?; end
  def azure_disk(*args, &block); end
  def azure_disk_present?; end
  def azure_file(*args, &block); end
  def azure_file_present?; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def capacity(&block); end

  def cephfs(*args, &block); end
  def cephfs_present?; end
  def cinder(*args, &block); end
  def cinder_present?; end
  def claim_ref(*args, &block); end
  def claim_ref_present?; end
  def csi(*args, &block); end
  def csi_present?; end
  def fc(*args, &block); end
  def fc_present?; end
  def flex_volume(*args, &block); end
  def flex_volume_present?; end
  def flocker(*args, &block); end
  def flocker_present?; end
  def gce_persistent_disk(*args, &block); end
  def gce_persistent_disk_present?; end
  def glusterfs(*args, &block); end
  def glusterfs_present?; end
  def host_path(*args, &block); end
  def host_path_present?; end
  def iscsi(*args, &block); end
  def iscsi_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def local(*args, &block); end
  def local_present?; end
  def mount_options(*args); end
  def nfs(*args, &block); end
  def nfs_present?; end
  def node_affinity(*args, &block); end
  def node_affinity_present?; end
  def persistent_volume_reclaim_policy(*args); end
  def photon_persistent_disk(*args, &block); end
  def photon_persistent_disk_present?; end
  def portworx_volume(*args, &block); end
  def portworx_volume_present?; end
  def quobyte(*args, &block); end
  def quobyte_present?; end
  def rbd(*args, &block); end
  def rbd_present?; end
  def scale_io(*args, &block); end
  def scale_io_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_class_name(*args); end
  def storageos(*args, &block); end
  def storageos_present?; end
  def volume_mode(*args); end
  def vsphere_volume(*args, &block); end
  def vsphere_volume_present?; end
end

class KubeDSL::DSL::V1::PersistentVolumeStatus < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end
  def phase(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PhotonPersistentDiskVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def pd_id(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Pod < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::PodAffinity < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def preferred_during_scheduling_ignored_during_execution(elem_name = T.unsafe(nil), &block); end
  def preferred_during_scheduling_ignored_during_executions; end
  def required_during_scheduling_ignored_during_execution(elem_name = T.unsafe(nil), &block); end
  def required_during_scheduling_ignored_during_executions; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodAffinityTerm < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def label_selector(*args, &block); end
  def label_selector_present?; end
  def namespace_selector(*args, &block); end
  def namespace_selector_present?; end
  def namespaces(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def topology_key(*args); end
end

class KubeDSL::DSL::V1::PodAntiAffinity < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def preferred_during_scheduling_ignored_during_execution(elem_name = T.unsafe(nil), &block); end
  def preferred_during_scheduling_ignored_during_executions; end
  def required_during_scheduling_ignored_during_execution(elem_name = T.unsafe(nil), &block); end
  def required_during_scheduling_ignored_during_executions; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_probe_time(*args); end
  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::V1::PodDNSConfig < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def nameservers(*args); end
  def option(elem_name = T.unsafe(nil), &block); end
  def options; end
  def searches(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodDNSConfigOption < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
end

class KubeDSL::DSL::V1::PodIP < ::KubeDSL::DSLObject
  def ip(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodReadinessGate < ::KubeDSL::DSLObject
  def condition_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodSecurityContext < ::KubeDSL::DSLObject
  def fs_group(*args); end
  def fs_group_change_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def run_as_group(*args); end
  def run_as_non_root(*args); end
  def run_as_user(*args); end
  def se_linux_options(*args, &block); end
  def se_linux_options_present?; end
  def seccomp_profile(*args, &block); end
  def seccomp_profile_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def supplemental_groups(*args); end
  def sysctls(elem_name = T.unsafe(nil), &block); end
  def sysctlses; end
  def windows_options(*args, &block); end
  def windows_options_present?; end
end

class KubeDSL::DSL::V1::PodSpec < ::KubeDSL::DSLObject
  def active_deadline_seconds(*args); end
  def affinity(*args, &block); end
  def affinity_present?; end
  def automount_service_account_token(*args); end
  def container(elem_name = T.unsafe(nil), &block); end
  def containers; end
  def dns_config(*args, &block); end
  def dns_config_present?; end
  def dns_policy(*args); end
  def enable_service_links(*args); end
  def ephemeral_container(elem_name = T.unsafe(nil), &block); end
  def ephemeral_containers; end
  def host_alias(elem_name = T.unsafe(nil), &block); end
  def host_aliases; end
  def host_ipc(*args); end
  def host_network(*args); end
  def host_pid(*args); end
  def hostname(*args); end
  def image_pull_secret(elem_name = T.unsafe(nil), &block); end
  def image_pull_secrets; end
  def init_container(elem_name = T.unsafe(nil), &block); end
  def init_containers; end

  sig { returns(Symbol) }
  def kind_sym; end

  def node_name(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def node_selector(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def overhead(&block); end

  def preemption_policy(*args); end
  def priority(*args); end
  def priority_class_name(*args); end
  def readiness_gate(elem_name = T.unsafe(nil), &block); end
  def readiness_gates; end
  def restart_policy(*args); end
  def runtime_class_name(*args); end
  def scheduler_name(*args); end
  def security_context(*args, &block); end
  def security_context_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service_account(*args); end
  def service_account_name(*args); end
  def set_hostname_as_fqdn(*args); end
  def share_process_namespace(*args); end
  def subdomain(*args); end
  def termination_grace_period_seconds(*args); end
  def toleration(elem_name = T.unsafe(nil), &block); end
  def tolerations; end
  def topology_spread_constraint(elem_name = T.unsafe(nil), &block); end
  def topology_spread_constraints; end
  def volume(elem_name = T.unsafe(nil), &block); end
  def volumes; end
end

class KubeDSL::DSL::V1::PodStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def container_status(elem_name = T.unsafe(nil), &block); end
  def container_statuses; end
  def ephemeral_container_status(elem_name = T.unsafe(nil), &block); end
  def ephemeral_container_statuses; end
  def host_ip(*args); end
  def init_container_status(elem_name = T.unsafe(nil), &block); end
  def init_container_statuses; end

  sig { returns(Symbol) }
  def kind_sym; end

  def message(*args); end
  def nominated_node_name(*args); end
  def phase(*args); end
  def pod_ip(elem_name = T.unsafe(nil), &block); end
  def pod_ips; end
  def qos_class(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def start_time(*args); end
end

class KubeDSL::DSL::V1::PodTemplate < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def template(*args, &block); end
  def template_present?; end
end

class KubeDSL::DSL::V1::PodTemplateList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PodTemplateSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
end

class KubeDSL::DSL::V1::PortStatus < ::KubeDSL::DSLObject
  def error(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def port(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::PortworxVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::PreferredSchedulingTerm < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def preference(*args, &block); end
  def preference_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def weight(*args); end
end

class KubeDSL::DSL::V1::Probe < ::KubeDSL::DSLObject
  def exec(*args, &block); end
  def exec_present?; end
  def failure_threshold(*args); end
  def http_get(*args, &block); end
  def http_get_present?; end
  def initial_delay_seconds(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def period_seconds(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def success_threshold(*args); end
  def tcp_socket(*args, &block); end
  def tcp_socket_present?; end
  def termination_grace_period_seconds(*args); end
  def timeout_seconds(*args); end
end

class KubeDSL::DSL::V1::ProjectedVolumeSource < ::KubeDSL::DSLObject
  def default_mode(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def source(elem_name = T.unsafe(nil), &block); end
  def sources; end
end

class KubeDSL::DSL::V1::QuobyteVolumeSource < ::KubeDSL::DSLObject
  def group(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def registry(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def tenant(*args); end
  def user(*args); end
  def volume(*args); end
end

class KubeDSL::DSL::V1::RBDPersistentVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end
  def image(*args); end
  def keyring(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def monitors(*args); end
  def pool(*args); end
  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def user(*args); end
end

class KubeDSL::DSL::V1::RBDVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end
  def image(*args); end
  def keyring(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def monitors(*args); end
  def pool(*args); end
  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def user(*args); end
end

class KubeDSL::DSL::V1::ReplicationController < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::ReplicationControllerCondition < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def last_transition_time(*args); end
  def message(*args); end
  def reason(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def status(*args); end
  def type(*args); end
end

class KubeDSL::DSL::V1::ReplicationControllerList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ReplicationControllerSpec < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def min_ready_seconds(*args); end
  def replicas(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def selector(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def template(*args, &block); end
  def template_present?; end
end

class KubeDSL::DSL::V1::ReplicationControllerStatus < ::KubeDSL::DSLObject
  def available_replicas(*args); end
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end
  def fully_labeled_replicas(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def observed_generation(*args); end
  def ready_replicas(*args); end
  def replicas(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ResourceFieldSelector < ::KubeDSL::DSLObject
  def container_name(*args); end
  def divisor(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def resource(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ResourceQuota < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::ResourceQuotaList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ResourceQuotaSpec < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def hard(&block); end

  sig { returns(Symbol) }
  def kind_sym; end

  def scope_selector(*args, &block); end
  def scope_selector_present?; end
  def scopes(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ResourceQuotaStatus < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def hard(&block); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def used(&block); end
end

class KubeDSL::DSL::V1::ResourceRequirements < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def limits(&block); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def requests(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SELinuxOptions < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def level(*args); end
  def role(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
  def user(*args); end
end

class KubeDSL::DSL::V1::ScaleIOPersistentVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end
  def gateway(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def protection_domain(*args); end
  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def ssl_enabled(*args); end
  def storage_mode(*args); end
  def storage_pool(*args); end
  def system(*args); end
  def volume_name(*args); end
end

class KubeDSL::DSL::V1::ScaleIOVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end
  def gateway(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def protection_domain(*args); end
  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def ssl_enabled(*args); end
  def storage_mode(*args); end
  def storage_pool(*args); end
  def system(*args); end
  def volume_name(*args); end
end

class KubeDSL::DSL::V1::ScopeSelector < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def match_expression(elem_name = T.unsafe(nil), &block); end
  def match_expressions; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ScopedResourceSelectorRequirement < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def operator(*args); end
  def scope_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def values(*args); end
end

class KubeDSL::DSL::V1::SeccompProfile < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def localhost_profile(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def type(*args); end
end

class KubeDSL::DSL::V1::Secret < ::KubeDSL::DSLObject
  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def data(&block); end

  def immutable(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def string_data(&block); end

  def type(*args); end
end

class KubeDSL::DSL::V1::SecretEnvSource < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SecretKeySelector < ::KubeDSL::DSLObject
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SecretList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SecretProjection < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def optional(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SecretReference < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def namespace(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SecretVolumeSource < ::KubeDSL::DSLObject
  def default_mode(*args); end
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def optional(*args); end
  def secret_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SecurityContext < ::KubeDSL::DSLObject
  def allow_privilege_escalation(*args); end
  def capabilities(*args, &block); end
  def capabilities_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def privileged(*args); end
  def proc_mount(*args); end
  def read_only_root_filesystem(*args); end
  def run_as_group(*args); end
  def run_as_non_root(*args); end
  def run_as_user(*args); end
  def se_linux_options(*args, &block); end
  def se_linux_options_present?; end
  def seccomp_profile(*args, &block); end
  def seccomp_profile_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def windows_options(*args, &block); end
  def windows_options_present?; end
end

class KubeDSL::DSL::V1::Service < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def spec(*args, &block); end
  def spec_present?; end
  def status(*args, &block); end
  def status_present?; end
end

class KubeDSL::DSL::V1::ServiceAccount < ::KubeDSL::DSLObject
  def automount_service_account_token(*args); end
  def image_pull_secret(elem_name = T.unsafe(nil), &block); end
  def image_pull_secrets; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end
  def secret(elem_name = T.unsafe(nil), &block); end
  def secrets; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ServiceAccountList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ServiceAccountTokenProjection < ::KubeDSL::DSLObject
  def audience(*args); end
  def expiration_seconds(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def path(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ServiceList < ::KubeDSL::DSLObject
  def item(elem_name = T.unsafe(nil), &block); end
  def items; end

  sig { returns(Symbol) }
  def kind_sym; end

  def metadata(*args, &block); end
  def metadata_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::ServicePort < ::KubeDSL::DSLObject
  def app_protocol(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def node_port(*args); end
  def port(*args); end
  def protocol(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def target_port(*args); end
end

class KubeDSL::DSL::V1::ServiceSpec < ::KubeDSL::DSLObject
  def allocate_load_balancer_node_ports(*args); end
  def cluster_i_ps(*args); end
  def cluster_ip(*args); end
  def external_i_ps(*args); end
  def external_name(*args); end
  def external_traffic_policy(*args); end
  def health_check_node_port(*args); end
  def internal_traffic_policy(*args); end
  def ip_families(*args); end
  def ip_family_policy(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def load_balancer_class(*args); end
  def load_balancer_ip(*args); end
  def load_balancer_source_ranges(*args); end
  def port(elem_name = T.unsafe(nil), &block); end
  def ports; end
  def publish_not_ready_addresses(*args); end

  sig { params(block: T.nilable(T.proc.void)).returns(::KubeDSL::KeyValueFields) }
  def selector(&block); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def session_affinity(*args); end
  def session_affinity_config(*args, &block); end
  def session_affinity_config_present?; end
  def type(*args); end
end

class KubeDSL::DSL::V1::ServiceStatus < ::KubeDSL::DSLObject
  def condition(elem_name = T.unsafe(nil), &block); end
  def conditions; end

  sig { returns(Symbol) }
  def kind_sym; end

  def load_balancer(*args, &block); end
  def load_balancer_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::SessionAffinityConfig < ::KubeDSL::DSLObject
  def client_ip(*args, &block); end
  def client_ip_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::StorageOSPersistentVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_name(*args); end
  def volume_namespace(*args); end
end

class KubeDSL::DSL::V1::StorageOSVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def read_only(*args); end
  def secret_ref(*args, &block); end
  def secret_ref_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def volume_name(*args); end
  def volume_namespace(*args); end
end

class KubeDSL::DSL::V1::Sysctl < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def value(*args); end
end

class KubeDSL::DSL::V1::TCPSocketAction < ::KubeDSL::DSLObject
  def host(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def port(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Taint < ::KubeDSL::DSLObject
  def effect(*args); end
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def time_added(*args); end
  def value(*args); end
end

class KubeDSL::DSL::V1::Toleration < ::KubeDSL::DSLObject
  def effect(*args); end
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def operator(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def toleration_seconds(*args); end
  def value(*args); end
end

class KubeDSL::DSL::V1::TopologySelectorLabelRequirement < ::KubeDSL::DSLObject
  def key(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def values(*args); end
end

class KubeDSL::DSL::V1::TopologySelectorTerm < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def match_label_expression(elem_name = T.unsafe(nil), &block); end
  def match_label_expressions; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::TopologySpreadConstraint < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def label_selector(*args, &block); end
  def label_selector_present?; end
  def max_skew(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def topology_key(*args); end
  def when_unsatisfiable(*args); end
end

class KubeDSL::DSL::V1::TypedLocalObjectReference < ::KubeDSL::DSLObject
  def api_group(*args); end
  def kind(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::Volume < ::KubeDSL::DSLObject
  def aws_elastic_block_store(*args, &block); end
  def aws_elastic_block_store_present?; end
  def azure_disk(*args, &block); end
  def azure_disk_present?; end
  def azure_file(*args, &block); end
  def azure_file_present?; end
  def cephfs(*args, &block); end
  def cephfs_present?; end
  def cinder(*args, &block); end
  def cinder_present?; end
  def config_map(*args, &block); end
  def config_map_present?; end
  def csi(*args, &block); end
  def csi_present?; end
  def downward_api(*args, &block); end
  def downward_api_present?; end
  def empty_dir(*args, &block); end
  def empty_dir_present?; end
  def ephemeral(*args, &block); end
  def ephemeral_present?; end
  def fc(*args, &block); end
  def fc_present?; end
  def flex_volume(*args, &block); end
  def flex_volume_present?; end
  def flocker(*args, &block); end
  def flocker_present?; end
  def gce_persistent_disk(*args, &block); end
  def gce_persistent_disk_present?; end
  def git_repo(*args, &block); end
  def git_repo_present?; end
  def glusterfs(*args, &block); end
  def glusterfs_present?; end
  def host_path(*args, &block); end
  def host_path_present?; end
  def iscsi(*args, &block); end
  def iscsi_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end
  def nfs(*args, &block); end
  def nfs_present?; end
  def persistent_volume_claim(*args, &block); end
  def persistent_volume_claim_present?; end
  def photon_persistent_disk(*args, &block); end
  def photon_persistent_disk_present?; end
  def portworx_volume(*args, &block); end
  def portworx_volume_present?; end
  def projected(*args, &block); end
  def projected_present?; end
  def quobyte(*args, &block); end
  def quobyte_present?; end
  def rbd(*args, &block); end
  def rbd_present?; end
  def scale_io(*args, &block); end
  def scale_io_present?; end
  def secret(*args, &block); end
  def secret_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storageos(*args, &block); end
  def storageos_present?; end
  def vsphere_volume(*args, &block); end
  def vsphere_volume_present?; end
end

class KubeDSL::DSL::V1::VolumeDevice < ::KubeDSL::DSLObject
  def device_path(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::VolumeMount < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def mount_path(*args); end
  def mount_propagation(*args); end
  def name(*args); end
  def read_only(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def sub_path(*args); end
  def sub_path_expr(*args); end
end

class KubeDSL::DSL::V1::VolumeNodeAffinity < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def required(*args, &block); end
  def required_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSL::V1::VolumeProjection < ::KubeDSL::DSLObject
  def config_map(*args, &block); end
  def config_map_present?; end
  def downward_api(*args, &block); end
  def downward_api_present?; end

  sig { returns(Symbol) }
  def kind_sym; end

  def secret(*args, &block); end
  def secret_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def service_account_token(*args, &block); end
  def service_account_token_present?; end
end

class KubeDSL::DSL::V1::VsphereVirtualDiskVolumeSource < ::KubeDSL::DSLObject
  def fs_type(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def storage_policy_id(*args); end
  def storage_policy_name(*args); end
  def volume_path(*args); end
end

class KubeDSL::DSL::V1::WeightedPodAffinityTerm < ::KubeDSL::DSLObject
  sig { returns(Symbol) }
  def kind_sym; end

  def pod_affinity_term(*args, &block); end
  def pod_affinity_term_present?; end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end

  def weight(*args); end
end

class KubeDSL::DSL::V1::WindowsSecurityContextOptions < ::KubeDSL::DSLObject
  def gmsa_credential_spec(*args); end
  def gmsa_credential_spec_name(*args); end
  def host_process(*args); end

  sig { returns(Symbol) }
  def kind_sym; end

  def run_as_user_name(*args); end

  sig do
    returns(T::Hash[Symbol, T.any(String, Integer, Float, T::Boolean, T::Array[T.untyped], T::Hash[Symbol, T.untyped])])
  end
  def serialize; end
end

class KubeDSL::DSLObject
  include ::KubeDSL::ValueFields::InstanceMethods
  include ::KubeDSL::Validations::InstanceMethods
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods
  extend ::KubeDSL::Validations
  extend ::KubeDSL::Validations::ClassMethods
  extend T::Sig

  sig { params(block: T.nilable(T.proc.void)).void }
  def initialize(&block); end

  sig { returns(T.any(String, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])) }
  def serialize; end

  sig { returns(::KubeDSL::Resource) }
  def to_resource; end
end

class KubeDSL::DefaultFieldRes
  include ::KubeDSL::StringHelpers

  def initialize(name, res, allowed_values); end

  def allowed_values; end
  def fields_to_rbi(_inflector); end
  def fields_to_ruby(_inflector); end
  def name; end
  def res; end
  def serialize_call(_inflector); end
  def validations(_inflector); end
end

module KubeDSL::Entrypoint
  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::ServiceReference) }
  def admissionregistration_v1_service_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::WebhookClientConfig) }
  def admissionregistration_v1_webhook_client_config(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Affinity) }
  def affinity(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::AggregationRule) }
  def aggregation_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::APIGroup) }
  def api_group(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::APIGroupList) }
  def api_group_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::APIResource) }
  def api_resource(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::APIResourceList) }
  def api_resource_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiregistration::V1::APIService) }
  def api_service(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiregistration::V1::APIServiceCondition) }
  def api_service_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiregistration::V1::APIServiceList) }
  def api_service_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiregistration::V1::APIServiceSpec) }
  def api_service_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiregistration::V1::APIServiceStatus) }
  def api_service_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::APIVersions) }
  def api_versions(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::ServiceReference) }
  def apiextensions_v1_service_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::WebhookClientConfig) }
  def apiextensions_v1_webhook_client_config(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiregistration::V1::ServiceReference) }
  def apiregistration_v1_service_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::AttachedVolume) }
  def attached_volume(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::TokenRequest) }
  def authentication_v1_token_request(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::AWSElasticBlockStoreVolumeSource) }
  def aws_elastic_block_store_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::AzureDiskVolumeSource) }
  def azure_disk_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::AzureFilePersistentVolumeSource) }
  def azure_file_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::AzureFileVolumeSource) }
  def azure_file_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Binding) }
  def binding(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::BoundObjectReference) }
  def bound_object_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Capabilities) }
  def capabilities(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::CephFSPersistentVolumeSource) }
  def ceph_fs_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::CephFSVolumeSource) }
  def ceph_fs_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Certificates::V1::CertificateSigningRequest) }
  def certificate_signing_request(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Certificates::V1::CertificateSigningRequestCondition) }
  def certificate_signing_request_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Certificates::V1::CertificateSigningRequestList) }
  def certificate_signing_request_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Certificates::V1::CertificateSigningRequestSpec) }
  def certificate_signing_request_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Certificates::V1::CertificateSigningRequestStatus) }
  def certificate_signing_request_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::CinderPersistentVolumeSource) }
  def cinder_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::CinderVolumeSource) }
  def cinder_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ClientIPConfig) }
  def client_ip_config(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::ClusterRole) }
  def cluster_role(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::ClusterRoleBinding) }
  def cluster_role_binding(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::ClusterRoleBindingList) }
  def cluster_role_binding_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::ClusterRoleList) }
  def cluster_role_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ComponentCondition) }
  def component_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ComponentStatus) }
  def component_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ComponentStatusList) }
  def component_status_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::Condition) }
  def condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMap) }
  def config_map(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMapEnvSource) }
  def config_map_env_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMapKeySelector) }
  def config_map_key_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMapList) }
  def config_map_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMapNodeConfigSource) }
  def config_map_node_config_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMapProjection) }
  def config_map_projection(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ConfigMapVolumeSource) }
  def config_map_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Container) }
  def container(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerImage) }
  def container_image(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerPort) }
  def container_port(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerState) }
  def container_state(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerStateRunning) }
  def container_state_running(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerStateTerminated) }
  def container_state_terminated(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerStateWaiting) }
  def container_state_waiting(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ContainerStatus) }
  def container_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ControllerRevision) }
  def controller_revision(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ControllerRevisionList) }
  def controller_revision_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::CronJob) }
  def cron_job(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::CronJobList) }
  def cron_job_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::CronJobSpec) }
  def cron_job_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::CronJobStatus) }
  def cron_job_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::CrossVersionObjectReference) }
  def cross_version_object_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSIDriver) }
  def csi_driver(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSIDriverList) }
  def csi_driver_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSIDriverSpec) }
  def csi_driver_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSINode) }
  def csi_node(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSINodeDriver) }
  def csi_node_driver(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSINodeList) }
  def csi_node_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::CSINodeSpec) }
  def csi_node_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::CSIPersistentVolumeSource) }
  def csi_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::CSIVolumeSource) }
  def csi_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceColumnDefinition) }
  def custom_resource_column_definition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceConversion) }
  def custom_resource_conversion(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinition) }
  def custom_resource_definition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionCondition) }
  def custom_resource_definition_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionList) }
  def custom_resource_definition_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionNames) }
  def custom_resource_definition_names(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionSpec) }
  def custom_resource_definition_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionStatus) }
  def custom_resource_definition_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionVersion) }
  def custom_resource_definition_version(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresourceScale) }
  def custom_resource_subresource_scale(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresources) }
  def custom_resource_subresources(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::CustomResourceValidation) }
  def custom_resource_validation(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::DaemonEndpoint) }
  def daemon_endpoint(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DaemonSet) }
  def daemon_set(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DaemonSetCondition) }
  def daemon_set_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DaemonSetList) }
  def daemon_set_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DaemonSetSpec) }
  def daemon_set_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DaemonSetStatus) }
  def daemon_set_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DaemonSetUpdateStrategy) }
  def daemon_set_update_strategy(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::DeleteOptions) }
  def delete_options(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::Deployment) }
  def deployment(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DeploymentCondition) }
  def deployment_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DeploymentList) }
  def deployment_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DeploymentSpec) }
  def deployment_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DeploymentStatus) }
  def deployment_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::DeploymentStrategy) }
  def deployment_strategy(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::EndpointPort) }
  def discovery_v1_endpoint_port(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::DownwardAPIProjection) }
  def downward_api_projection(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::DownwardAPIVolumeFile) }
  def downward_api_volume_file(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::DownwardAPIVolumeSource) }
  def downward_api_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EmptyDirVolumeSource) }
  def empty_dir_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::Endpoint) }
  def endpoint(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EndpointAddress) }
  def endpoint_address(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::EndpointConditions) }
  def endpoint_conditions(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::EndpointHints) }
  def endpoint_hints(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::EndpointSlice) }
  def endpoint_slice(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::EndpointSliceList) }
  def endpoint_slice_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EndpointSubset) }
  def endpoint_subset(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Endpoints) }
  def endpoints(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EndpointsList) }
  def endpoints_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EnvFromSource) }
  def env_from_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EnvVar) }
  def env_var(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EnvVarSource) }
  def env_var_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EphemeralContainer) }
  def ephemeral_container(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EphemeralVolumeSource) }
  def ephemeral_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EventSource) }
  def event_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Events::V1::Event) }
  def events_v1_event(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Events::V1::EventList) }
  def events_v1_event_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Events::V1::EventSeries) }
  def events_v1_event_series(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Policy::V1::Eviction) }
  def eviction(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ExecAction) }
  def exec_action(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::ExternalDocumentation) }
  def external_documentation(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::FCVolumeSource) }
  def fc_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::FlexPersistentVolumeSource) }
  def flex_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::FlexVolumeSource) }
  def flex_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::FlockerVolumeSource) }
  def flocker_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Discovery::V1::ForZone) }
  def for_zone(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::GCEPersistentDiskVolumeSource) }
  def gce_persistent_disk_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::GitRepoVolumeSource) }
  def git_repo_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::GlusterfsPersistentVolumeSource) }
  def glusterfs_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::GlusterfsVolumeSource) }
  def glusterfs_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::GroupVersionForDiscovery) }
  def group_version_for_discovery(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Handler) }
  def handler(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscaler) }
  def horizontal_pod_autoscaler(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerList) }
  def horizontal_pod_autoscaler_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerSpec) }
  def horizontal_pod_autoscaler_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerStatus) }
  def horizontal_pod_autoscaler_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::HostAlias) }
  def host_alias(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::HostPathVolumeSource) }
  def host_path_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::HTTPGetAction) }
  def http_get_action(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::HTTPHeader) }
  def http_header(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::HTTPIngressPath) }
  def http_ingress_path(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::HTTPIngressRuleValue) }
  def http_ingress_rule_value(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Pkg::Version::Info) }
  def info(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::Ingress) }
  def ingress(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressBackend) }
  def ingress_backend(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressClass) }
  def ingress_class(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressClassList) }
  def ingress_class_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressClassParametersReference) }
  def ingress_class_parameters_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressClassSpec) }
  def ingress_class_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressList) }
  def ingress_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressRule) }
  def ingress_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressServiceBackend) }
  def ingress_service_backend(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressSpec) }
  def ingress_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressStatus) }
  def ingress_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IngressTLS) }
  def ingress_tls(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::IPBlock) }
  def ip_block(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ISCSIPersistentVolumeSource) }
  def iscsi_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ISCSIVolumeSource) }
  def iscsi_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::Job) }
  def job(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::JobCondition) }
  def job_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::JobList) }
  def job_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::JobSpec) }
  def job_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::JobStatus) }
  def job_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::JobTemplateSpec) }
  def job_template_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::JSONSchemaProps) }
  def json_schema_props(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::KeyToPath) }
  def key_to_path(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::LabelSelector) }
  def label_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::LabelSelectorRequirement) }
  def label_selector_requirement(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Coordination::V1::Lease) }
  def lease(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Coordination::V1::LeaseList) }
  def lease_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Coordination::V1::LeaseSpec) }
  def lease_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Lifecycle) }
  def lifecycle(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LimitRange) }
  def limit_range(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LimitRangeItem) }
  def limit_range_item(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LimitRangeList) }
  def limit_range_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LimitRangeSpec) }
  def limit_range_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::ListMeta) }
  def list_meta(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LoadBalancerIngress) }
  def load_balancer_ingress(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LoadBalancerStatus) }
  def load_balancer_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LocalObjectReference) }
  def local_object_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::LocalSubjectAccessReview) }
  def local_subject_access_review(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::LocalVolumeSource) }
  def local_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::ManagedFieldsEntry) }
  def managed_fields_entry(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::MutatingWebhook) }
  def mutating_webhook(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfiguration) }
  def mutating_webhook_configuration(&block); end

  sig do
    params(
      block: T.proc.void
    ).returns(::KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfigurationList)
  end
  def mutating_webhook_configuration_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Namespace) }
  def namespace(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NamespaceCondition) }
  def namespace_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NamespaceList) }
  def namespace_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NamespaceSpec) }
  def namespace_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NamespaceStatus) }
  def namespace_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicy) }
  def network_policy(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicyEgressRule) }
  def network_policy_egress_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicyIngressRule) }
  def network_policy_ingress_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicyList) }
  def network_policy_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicyPeer) }
  def network_policy_peer(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicyPort) }
  def network_policy_port(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::NetworkPolicySpec) }
  def network_policy_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NFSVolumeSource) }
  def nfs_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Node) }
  def node(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeAddress) }
  def node_address(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeAffinity) }
  def node_affinity(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeCondition) }
  def node_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeConfigSource) }
  def node_config_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeConfigStatus) }
  def node_config_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeDaemonEndpoints) }
  def node_daemon_endpoints(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeList) }
  def node_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeSelector) }
  def node_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeSelectorRequirement) }
  def node_selector_requirement(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeSelectorTerm) }
  def node_selector_term(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeSpec) }
  def node_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeStatus) }
  def node_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::NodeSystemInfo) }
  def node_system_info(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::NonResourceAttributes) }
  def non_resource_attributes(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::NonResourceRule) }
  def non_resource_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ObjectFieldSelector) }
  def object_field_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::ObjectMeta) }
  def object_meta(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ObjectReference) }
  def object_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Node::V1::Overhead) }
  def overhead(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::OwnerReference) }
  def owner_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolume) }
  def persistent_volume(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaim) }
  def persistent_volume_claim(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaimCondition) }
  def persistent_volume_claim_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaimList) }
  def persistent_volume_claim_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaimSpec) }
  def persistent_volume_claim_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaimStatus) }
  def persistent_volume_claim_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaimTemplate) }
  def persistent_volume_claim_template(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeClaimVolumeSource) }
  def persistent_volume_claim_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeList) }
  def persistent_volume_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeSpec) }
  def persistent_volume_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PersistentVolumeStatus) }
  def persistent_volume_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PhotonPersistentDiskVolumeSource) }
  def photon_persistent_disk_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Pod) }
  def pod(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodAffinity) }
  def pod_affinity(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodAffinityTerm) }
  def pod_affinity_term(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodAntiAffinity) }
  def pod_anti_affinity(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodCondition) }
  def pod_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Policy::V1::PodDisruptionBudget) }
  def pod_disruption_budget(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Policy::V1::PodDisruptionBudgetList) }
  def pod_disruption_budget_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Policy::V1::PodDisruptionBudgetSpec) }
  def pod_disruption_budget_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Policy::V1::PodDisruptionBudgetStatus) }
  def pod_disruption_budget_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodDNSConfig) }
  def pod_dns_config(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodDNSConfigOption) }
  def pod_dns_config_option(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodIP) }
  def pod_ip(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodList) }
  def pod_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodReadinessGate) }
  def pod_readiness_gate(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodSecurityContext) }
  def pod_security_context(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodSpec) }
  def pod_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodStatus) }
  def pod_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodTemplate) }
  def pod_template(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodTemplateList) }
  def pod_template_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PodTemplateSpec) }
  def pod_template_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::PolicyRule) }
  def policy_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PortStatus) }
  def port_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PortworxVolumeSource) }
  def portworx_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::Preconditions) }
  def preconditions(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::PreferredSchedulingTerm) }
  def preferred_scheduling_term(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Scheduling::V1::PriorityClass) }
  def priority_class(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Scheduling::V1::PriorityClassList) }
  def priority_class_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Probe) }
  def probe(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ProjectedVolumeSource) }
  def projected_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::QuobyteVolumeSource) }
  def quobyte_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::RBDPersistentVolumeSource) }
  def rbd_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::RBDVolumeSource) }
  def rbd_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ReplicaSet) }
  def replica_set(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ReplicaSetCondition) }
  def replica_set_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ReplicaSetList) }
  def replica_set_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ReplicaSetSpec) }
  def replica_set_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::ReplicaSetStatus) }
  def replica_set_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ReplicationController) }
  def replication_controller(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ReplicationControllerCondition) }
  def replication_controller_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ReplicationControllerList) }
  def replication_controller_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ReplicationControllerSpec) }
  def replication_controller_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ReplicationControllerStatus) }
  def replication_controller_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::ResourceAttributes) }
  def resource_attributes(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ResourceFieldSelector) }
  def resource_field_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ResourceQuota) }
  def resource_quota(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ResourceQuotaList) }
  def resource_quota_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ResourceQuotaSpec) }
  def resource_quota_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ResourceQuotaStatus) }
  def resource_quota_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ResourceRequirements) }
  def resource_requirements(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::ResourceRule) }
  def resource_rule(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::Role) }
  def role(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::RoleBinding) }
  def role_binding(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::RoleBindingList) }
  def role_binding_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::RoleList) }
  def role_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::RoleRef) }
  def role_ref(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::RollingUpdateDaemonSet) }
  def rolling_update_daemon_set(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::RollingUpdateDeployment) }
  def rolling_update_deployment(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::RollingUpdateStatefulSetStrategy) }
  def rolling_update_stateful_set_strategy(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::RuleWithOperations) }
  def rule_with_operations(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Node::V1::RuntimeClass) }
  def runtime_class(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Node::V1::RuntimeClassList) }
  def runtime_class_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::Scale) }
  def scale(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ScaleIOPersistentVolumeSource) }
  def scale_io_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ScaleIOVolumeSource) }
  def scale_io_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::ScaleSpec) }
  def scale_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Autoscaling::V1::ScaleStatus) }
  def scale_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Node::V1::Scheduling) }
  def scheduling(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ScopeSelector) }
  def scope_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ScopedResourceSelectorRequirement) }
  def scoped_resource_selector_requirement(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SELinuxOptions) }
  def se_linux_options(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SeccompProfile) }
  def seccomp_profile(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Secret) }
  def secret(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecretEnvSource) }
  def secret_env_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecretKeySelector) }
  def secret_key_selector(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecretList) }
  def secret_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecretProjection) }
  def secret_projection(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecretReference) }
  def secret_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecretVolumeSource) }
  def secret_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SecurityContext) }
  def security_context(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReview) }
  def self_subject_access_review(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReviewSpec) }
  def self_subject_access_review_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReview) }
  def self_subject_rules_review(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReviewSpec) }
  def self_subject_rules_review_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::ServerAddressByClientCIDR) }
  def server_address_by_client_cidr(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Service) }
  def service(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServiceAccount) }
  def service_account(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServiceAccountList) }
  def service_account_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServiceAccountTokenProjection) }
  def service_account_token_projection(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Networking::V1::ServiceBackendPort) }
  def service_backend_port(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServiceList) }
  def service_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServicePort) }
  def service_port(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServiceSpec) }
  def service_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::ServiceStatus) }
  def service_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::SessionAffinityConfig) }
  def session_affinity_config(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::StatefulSet) }
  def stateful_set(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::StatefulSetCondition) }
  def stateful_set_condition(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::StatefulSetList) }
  def stateful_set_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::StatefulSetSpec) }
  def stateful_set_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::StatefulSetStatus) }
  def stateful_set_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apps::V1::StatefulSetUpdateStrategy) }
  def stateful_set_update_strategy(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::Status) }
  def status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::StatusCause) }
  def status_cause(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::StatusDetails) }
  def status_details(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::StorageClass) }
  def storage_class(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::StorageClassList) }
  def storage_class_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::StorageOSPersistentVolumeSource) }
  def storage_os_persistent_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::StorageOSVolumeSource) }
  def storage_os_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::TokenRequest) }
  def storage_v1_token_request(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Rbac::V1::Subject) }
  def subject(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SubjectAccessReview) }
  def subject_access_review(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SubjectAccessReviewSpec) }
  def subject_access_review_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SubjectAccessReviewStatus) }
  def subject_access_review_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authorization::V1::SubjectRulesReviewStatus) }
  def subject_rules_review_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Sysctl) }
  def sysctl(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Taint) }
  def taint(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::TCPSocketAction) }
  def tcp_socket_action(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::TokenRequestSpec) }
  def token_request_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::TokenRequestStatus) }
  def token_request_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::TokenReview) }
  def token_review(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::TokenReviewSpec) }
  def token_review_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::TokenReviewStatus) }
  def token_review_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Toleration) }
  def toleration(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::TopologySelectorLabelRequirement) }
  def topology_selector_label_requirement(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::TopologySelectorTerm) }
  def topology_selector_term(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::TopologySpreadConstraint) }
  def topology_spread_constraint(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::TypedLocalObjectReference) }
  def typed_local_object_reference(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Batch::V1::UncountedTerminatedPods) }
  def uncounted_terminated_pods(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Authentication::V1::UserInfo) }
  def user_info(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EndpointPort) }
  def v1_endpoint_port(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Event) }
  def v1_event(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EventList) }
  def v1_event_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::EventSeries) }
  def v1_event_series(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhook) }
  def validating_webhook(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfiguration) }
  def validating_webhook_configuration(&block); end

  sig do
    params(
      block: T.proc.void
    ).returns(::KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfigurationList)
  end
  def validating_webhook_configuration_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::Volume) }
  def volume(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeAttachment) }
  def volume_attachment(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeAttachmentList) }
  def volume_attachment_list(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeAttachmentSource) }
  def volume_attachment_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeAttachmentSpec) }
  def volume_attachment_spec(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeAttachmentStatus) }
  def volume_attachment_status(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::VolumeDevice) }
  def volume_device(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeError) }
  def volume_error(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::VolumeMount) }
  def volume_mount(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::VolumeNodeAffinity) }
  def volume_node_affinity(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Storage::V1::VolumeNodeResources) }
  def volume_node_resources(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::VolumeProjection) }
  def volume_projection(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::VsphereVirtualDiskVolumeSource) }
  def vsphere_virtual_disk_volume_source(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Meta::V1::WatchEvent) }
  def watch_event(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::Apiextensions::V1::WebhookConversion) }
  def webhook_conversion(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::WeightedPodAffinityTerm) }
  def weighted_pod_affinity_term(&block); end

  sig { params(block: T.proc.void).returns(::KubeDSL::DSL::V1::WindowsSecurityContextOptions) }
  def windows_security_context_options(&block); end
end

class KubeDSL::EntrypointBuilder
  include ::KubeDSL::StringHelpers

  def initialize(builder, &block); end

  def block; end
  def builder; end
  def entrypoint; end
  def entrypoint_rbi; end
  def path; end
  def rbi_path; end

  private

  def ambiguous_kinds; end
  def indent; end
  def indent_level; end
  def kinds; end
  def method_name_for(resource); end
  def module_namespace; end
end

class KubeDSL::ExternalRef < ::KubeDSL::Ref
  def document; end
  def meta; end
  def object?; end
end

class KubeDSL::ExternalResourceMeta
  def initialize(ref); end

  def external?; end
  def ref; end
end

class KubeDSL::FieldRes
  include ::KubeDSL::StringHelpers
  include ::KubeDSL::RbiHelpers

  def initialize(name, type, required); end

  def fields_to_rbi(inflector); end
  def fields_to_ruby(_inflector); end
  def name; end
  def required; end
  def required?; end
  def serialize_call(_inflector); end
  def type; end
  def validations(_inflector); end

  private

  def ruby_safe_name; end
end

class KubeDSL::Generator
  def initialize(*args, **kwargs); end

  def builder; end
  def generate(include_rbi: T.unsafe(nil)); end
  def generate_autoload_files; end
  def generate_entrypoint_file(include_rbi: T.unsafe(nil), &block); end
  def generate_resource_files(include_rbi: T.unsafe(nil)); end
end

class KubeDSL::Inflector
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def inflector; end

  class << self
    def pluralize(*args); end
    def singularize(*args); end
  end
end

class KubeDSL::InlineRef
  def initialize(name, document, parent_ref, serialize_handlers); end

  def document; end
  def inline?; end
  def kind; end
  def meta; end
  def method_missing(method_name, *args, **kwargs, &block); end
  def name; end
  def parent_ref; end
  def ruby_autoload_path; end
  def serialize_handlers; end
  def str; end

  private

  def respond_to_missing?(method_name); end
end

KubeDSL::KUBERNETES_VERSION = T.let(T.unsafe(nil), String)

class KubeDSL::KeyValueFieldRes
  include ::KubeDSL::StringHelpers

  def initialize(name, res, type, required); end

  def fields_to_rbi(_inflector); end
  def fields_to_ruby(_inflector); end
  def name; end
  def required; end
  def required?; end
  def res; end
  def serialize_call(_inflector); end
  def type; end
  def validations(_inflector); end
end

class KubeDSL::KeyValueFields
  extend T::Sig

  def initialize(format: T.unsafe(nil)); end

  def add(key, value); end
  def format; end
  def get(key); end
  def kv_pairs; end
  def merge!(other); end
  def remove(key); end

  sig { returns(T::Hash[Symbol, String]) }
  def serialize; end

  def set(key, value); end

  private

  def serialize_value(data); end
end

class KubeDSL::ObjectFieldRes
  include ::KubeDSL::StringHelpers

  def initialize(name, res); end

  def fields_to_rbi(_inflector); end
  def fields_to_ruby(_inflector); end
  def name; end
  def res; end
  def serialize_call(_inflector); end
  def validations(_inflector); end

  private

  def ruby_safe_name; end
  def ruby_type; end
end

module KubeDSL::RbiHelpers
  include ::KubeDSL::StringHelpers

  def rbi_type_for(type_str); end
end

KubeDSL::RbiHelpers::TYPE_MAP = T.let(T.unsafe(nil), Hash)

class KubeDSL::Ref
  include ::KubeDSL::StringHelpers

  def initialize(str, ruby_namespace_prefix, inflector, schema_dir, autoload_prefix, serialize_handlers); end

  def autoload_prefix; end
  def document; end
  def inflector; end
  def inline?; end
  def kind; end
  def meta; end
  def namespace; end
  def object?; end
  def ruby_autoload_path; end
  def ruby_namespace; end
  def ruby_namespace_prefix; end
  def schema_dir; end
  def serialize_handlers; end
  def str; end
  def version; end

  private

  def filename; end
end

class KubeDSL::Resource
  extend T::Sig

  def initialize(contents); end

  def contents; end

  sig { returns(T.nilable(T.any(String, T::Array[T.untyped], T::Hash[T.untyped, T.untyped]))) }
  def serialize; end

  sig { returns(KubeDSL::Resource) }
  def to_resource; end

  sig { returns(String) }
  def to_yaml; end

  private

  def cleanup(obj); end
end

class KubeDSL::ResourceMeta
  include ::KubeDSL::StringHelpers

  def initialize(ref, inflector, serialize_handlers); end

  def empty?; end
  def external?; end
  def fields; end
  def inflector; end
  def ref; end
  def serialize_handlers; end
  def to_rbi; end
  def to_ruby; end

  private

  def fields_to_rbi(level); end
  def fields_to_ruby(level); end
  def indent(*lines, level); end
  def quote_sym(sym_str); end
  def serialize_call_for(field); end
  def serialize_method(level); end
  def validations(level); end
end

class KubeDSL::SerializeHandler
  def initialize(namespace, version, kind, field, &block); end

  def block; end
  def field; end
  def handle(res, inflector); end
  def kind; end
  def matches?(ref, field); end
  def namespace; end
  def version; end
end

module KubeDSL::StringHelpers
  extend ::KubeDSL::StringHelpers

  def capitalize(str); end
  def underscore(str); end
  def unkeywordify(str); end
end

KubeDSL::StringHelpers::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)
KubeDSL::VERSION = T.let(T.unsafe(nil), String)
class KubeDSL::ValidationError < ::StandardError; end

module KubeDSL::Validations
  class << self
    def extended(base); end
  end
end

class KubeDSL::Validations::ArrayValidator
  def initialize(field_name, opts); end

  def field_name; end
  def kind_of; end
  def validate(obj, errors, nesting); end
end

module KubeDSL::Validations::ClassMethods
  def validates(field_name, options); end

  sig { returns(T.untyped) }
  def validators; end
end

class KubeDSL::Validations::FieldValidator
  def initialize(field_name, options = T.unsafe(nil)); end

  def field_name; end
  def format_validator; end
  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::FormatValidator
  def initialize(format); end

  def format; end

  sig { returns(T.untyped) }
  def klasses; end

  def valid?(obj); end
end

class KubeDSL::Validations::InclusionValidator
  def initialize(field_name, opts); end

  def field_name; end
  def list; end
  def validate(obj, errors, nesting); end
end

module KubeDSL::Validations::InstanceMethods
  sig { returns(T.untyped) }
  def valid?; end

  def validate(errors = T.unsafe(nil), nesting = T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def validate!; end
end

class KubeDSL::Validations::KeyValueValidator
  def initialize(field_name, options = T.unsafe(nil)); end

  def field_name; end
  def format_validator; end
  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::ObjectValidator
  def initialize(field_name, opts); end

  def field_name; end
  def kind_of; end
  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::PresenceValidator
  def initialize(field_name, presence); end

  def field_name; end
  def presence; end
  def validate(obj, errors, nesting); end

  private

  def obj_empty?(obj); end
end

class KubeDSL::Validations::ValidationErrors
  sig { void }
  def initialize; end

  def add(field_name, msg); end

  sig { returns(T.untyped) }
  def empty?; end

  def messages; end
end

module KubeDSL::ValueFields
  class << self
    def extended(base); end
  end
end

module KubeDSL::ValueFields::ClassMethods
  sig { returns(T.untyped) }
  def __fields__; end

  def array_field(field, accessor = T.unsafe(nil), &field_block); end
  def key_value_field(field, format:); end
  def object_field(field, allow_empty: T.unsafe(nil), &field_block); end
  def value_field(field, default: T.unsafe(nil)); end

  sig { params(fields: T.untyped).returns(T.untyped) }
  def value_fields(*fields); end
end

class KubeDSL::ValueFields::ClassMismatchError < ::StandardError; end

module KubeDSL::ValueFields::InstanceMethods
  def merge(other, fields); end
  def merge!(other, fields: T.unsafe(nil)); end
end
